<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>dashayu - 我的技术博客</title>
    <link>http://dashayu.tk</link>
    <pubDate>24 Jan 15 22:18 CST</pubDate>
    <item>
      <title>python爬虫基础</title>
      <link>http://dashayu.tk/default/python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</link>
      <pubDate>2014-12-02 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;基本的抓取&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;import urllib&#xA;content = urllib.urlopen(&#39;http://www.x.com&#39;).read()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;使用代理服务器&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;proxy = urllib2.ProxyHandler({&#39;http&#39;:&#39;http://host:port&#39;}) &#xA;opener = urllib2.build_opener(proxy, urllib2.HTTPHandler) &#xA;urllib2.install_opener(opener) &#xA;content = urllib2.urlopen(&#39;http://www.xxxx.com&#39;).read()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;Cookie&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;import urllib2, cookielib &#xA;cookie = urllib2.HTTPCookieProcessor(cookielib.CookieJar()) &#xA;opener = urllib2.build_opener(cookie, urllib2.HTTPHandler) &#xA;urllib2.install_opener(opener) &#xA;content = urllib2.urlopen(&#39;http://www.xxx.com&#39;).read()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;POST 数据&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;比如说需要向 &lt;a href=&#34;http://www.xxx.com/post/&#34;&gt;http://www.xxx.com/post/&lt;/a&gt; 接口 POST 数据 name=’liluo’, age=’21’, blog=’http://liluo.org’&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先需要准备数据&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;data = urllib.urlencode({ &#xA;    &#39;name&#39;: &#39;liluo&#39;, &#xA;    &#39;age&#39; : &#39;21&#39;, &#xA;    &#39;blog&#39;: &#39;http://liluo.org&#39; &#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后生成并发送 HTTP 请求&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;req = urllib2.Request(url=&#39;http://www.xxx.com/post/&#39;, data=data) &#xA;ret = urllib2.urlopen(req).read()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;伪装成浏览器&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;很多网站不喜欢爬虫（比如糗事百科），发送的请求会被拒绝。这个时候我们可以用修改 HTTP headers 信息来伪装成浏览器:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;headers = {&#xA;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19&#39;&#xA;} &#xA;req = urllib2.Request( &#xA;    url = &#39;http://www.xxx.com&#39;, &#xA;    headers = headers &#xA;) &#xA;ret = urllib2.urlopen(req).read()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;绕过“反盗链”&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;某些网站（再比如糗事百科）图片会有所谓的反盗链设置，其实就是检查 HTTP 请求的 headers 里的 referer 是否来自该网站。所以只需改下 headers:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;headers = {&#39;Referer&#39;: &#39;http://www.qiushibai.com&#39; } &#xA;req = urllib2.Request( &#xA;    url = &#39;http://qiushibaike.com/&#39;, &#xA;    headers = headers&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Tkinter学习笔记</title>
      <link>http://dashayu.tk/default/Tkinter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>2014-12-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;什么是tkinter&#34; href=&#34;#什么是tkinter&#34;&gt;&lt;/a&gt;什么是Tkinter&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Tkinter（也叫Tk接口）是Tk图形用户界面工具包标准的Python接口。Tk是一个轻量级的跨平台图形用户界面（GUI）开发工具。Tk和Tkinter可以运行在大多数的Unix平台、Windows、和Macintosh系统。&#xA;Tkinter 由一定数量的模块组成。Tkinter位于一个名为_tkinter（较早的版本名为tkinter）的二进制模块中 。Tkinter包含了对Tk的低 级接口模块，低级接口并不会被应用级程序员直接使用，通常是一个共享库（或DLL），但是在一些情况下它也被Python解释器静态链接。&#xA;除了Tk接口模块，Tkinter也包含了一定数量的Python模块。其中两个最重要的模块是Tkinter本身和名为Tkconstants的模块。前者自动引导后者，因此使用Tkinter，你首先需要做的是导入Tkinter模块，&#xA;代码如下：&#xA;import Tkinter&#xA;或&#xA;from Tkinter import *&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;第一个Tkinter程序&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;File: hello1.py&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from Tkinter import *&#xA;&#xA;root = Tk()&#xA;&#xA;w = Label(root, text=&amp;quot;Hello, world!&amp;quot;)&#xA;w.pack()&#xA;&#xA;root.mainloop()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;运行结果如下：&#xA;转-Tkinter入门(一)&#xA;关闭这个窗口即可终止这个程序的运行。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二、对代码的说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们通过导入Tkinter模块开始。Tkinter模块包含了用Tk工具包工作所需的所有的类，函数和其它一些必须的东西。在大多数情况下，你只需要简单的从Tkinter导入所有的东西到你的模块的名字空间，如下所示：&#xA;from Tkinter import *&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然 后初始化Tkinter,方法是我们必须先创建一个Tk root（根）窗口部件，它是一个普通的窗口，带有标题条和其它由你的窗口管理器供给的附属。你 应该只创建一个root窗口部件，这个root窗口部件必须在其它窗口部件创建之前创建。初始化Tkinter的代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;root = Tk()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;接着我们创建一个Label（标签）窗口部件作为这个root窗口的孩子，代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;w = Label(root, text=&amp;quot;Hello, world!&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Label窗口部件可以显示文本、图标或图象。我们这里用text选项来指定要显示的文本。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来我们在Label窗口部件上调用了pack方法，它告诉Label窗口部件去调整自己的尺寸来适应所给定文本的大小，并且使用自己可见，代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;w.pack()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但是在这些发生之前，我们必须进入Tkinter的事件循环，代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;root.mainloop()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这 个程序将一直处在事件循环之中，直到我们关闭了这个窗口。事件循环不仅仅处理来自用户的事件（如鼠标敲击和按键按下）或者窗口系统（重绘事件和窗口配置消 息），它也处理来自Tkinter自身的工作等待队列，这些工作之一就包括由pack方法所产生的工作和显示更新。这就意味着这个应用程序窗口在进入这个 事件循环之前将不会显示出来。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;第二个Tkinter程序&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;当我们在写一个较大的程序的时候，把代码封装在类中通常是一个好的主意。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;File: hello2.py&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;from Tkinter import *&#xA;&#xA;class App:&#xA;&#xA;    def __init__(self, master):&#xA;&#xA;        frame = Frame(master)&#xA;        frame.pack()&#xA;&#xA;        self.button = Button(frame, text=&amp;quot;QUIT&amp;quot;, fg=&amp;quot;red&amp;quot;, command=frame.quit)&#xA;        self.button.pack(side=LEFT)&#xA;&#xA;        self.hi_there = Button(frame, text=&amp;quot;Hello&amp;quot;, command=self.say_hi)&#xA;        self.hi_there.pack(side=LEFT)&#xA;&#xA;    def say_hi(self):&#xA;        print &amp;quot;hi there, everyone!&amp;quot;&#xA;&#xA;root = Tk()&#xA;&#xA;app = App(root)&#xA;&#xA;root.mainloop()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;运行结果如下：&#xA;转-Tkinter入门(一)&#xA;如果你点击Hello按钮，将在控制台打印出&amp;rdquo;hi there, everyone!&amp;rdquo; 。如果你点击QUIT按钮，程序将终止。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;二、代码说明：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个简单的应用程序被写成了一个类。这个构造器（&lt;strong&gt;init&lt;/strong&gt; 方法）通过一个父部件被调用，并针对父部件增加了一些子部件。构造器通过创建一个Frame（帧）窗口部件开始。一个帧是一个简单的容器，在这个例子中，我们仅用来容纳另外的两个部件。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;class App:&#xA;    def __init__(self, master):&#xA;        frame = Frame(master)&#xA;        frame.pack()&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个帧实例被存储在一个名为Frame的局部变量中。在创建了这个部件后，我们立即调用pack方法来使用这个帧可见。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后我们创建两个Button（按钮）窗口部件作为这个帧的孩子。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;self.button = Button(frame, text=&amp;quot;QUIT&amp;quot;, fg=&amp;quot;red&amp;quot;, command=frame.quit)&#xA;self.button.pack(side=LEFT)&#xA;&#xA;self.hi_there = Button(frame, text=&amp;quot;Hello&amp;quot;, command=self.say_hi)&#xA;self.hi_there.pack(side=LEFT)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这次，我们传递了一定数量的选项给构造器。第一个按钮被标为&amp;rdquo;QUIT&amp;rdquo;，字为红色（fg是foreground&amp;lt;前景色&amp;gt;的缩写）。第二个被标为&amp;rdquo;Hello&amp;rdquo;。两个按钮都有一个command选项。这个选项指定了一个函数或方法，在按钮被点击时会被调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;按 钮实例被存储在实例属性组中。side=LEFT 参数表示这两个按钮在帧中将被分开放置；第一个按钮被放置在帧的左边缘，第二个被放在第一个的右边（帧 的左边缘仍保留着空格）。默认情况下，部件的放置都是相对于它们的父亲（frame部件相对于master，button相对于frame）。如果 side选项没指定，side默认值为TOP。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;ldquo;Hello&amp;rdquo;按钮的回调函数如下所示，它在按钮每次被按下时简单地打印一条信息给控制台：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;def say_hi(self):&#xA;    print &amp;quot;hi there, everyone!&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后我们提供了一些脚本级的代码来创建一个Tk root部件，和一个App类的实例（这个实例使用这个root部件作为它的父亲）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;root = Tk()&#xA;&#xA;app = App(root)&#xA;&#xA;root.mainloop()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;root.mainloop()调用root部件的mainloop方法。它进入Tk事件循环，这个应用程序将处于这个Tk事件循环之中直到quit方法被调用（点击QUIT按钮），或窗口被关闭。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于窗口部件引用&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在第二个例子中，frame部件被存储在一个名为frame的局部变量中，而button部件则存储在两个实例的属性组中。这是否隐藏着一个严重的问题呢：当 &lt;strong&gt;init&lt;/strong&gt; 函数返回并且frame变量超出了范围会发生什么呢？。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不 要紧；这儿确实没有必要去保持对窗口部件实例的引用。Tkinter自动维护一个窗口部件树（通过对象实例的master和children属性），因 此，当应用程序的最后一个引用消失时窗口部件不会消失；窗口部件必须显示的用destroy方法销毁。但是如果你希望在窗口部件被创建以后用它来做一些事 情，你最好保持对你自己的窗口部件实例的引用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意如果你不需要保持对一个窗口部件的引用，你可以用单独的一行来创建和pack（包装）它，如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;Button(frame, text=&amp;quot;Hello&amp;quot;, command=self.hello).pack(side=LEFT)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;不要存储这个操作的结果，当你试图去用这个结果时你会很失望（因为pack方法返回None）。为小心起见，最好将将pack（包装）分开，如下所示：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;w = Button(frame, text=&amp;quot;Hello&amp;quot;, command=self.hello) &#xA;w.pack(side=LEFT)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;关于窗口部件的名字&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一个容量引起混淆的方面（尤其是使用Tcl编程Tk的有一些经验的人）是Tinter的窗口部件的名字的概念。在Tcl中，你必须显示的命名每一个窗口 部件。例如下面的Tcl命令创建一个名为ok的按钮作为名为dialog的窗口部件的孩子（dialog又是root窗口的孩子）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;button .dialog.ok&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;相应的Tkinter调用将如下：&#xA;ok = Button(dialog)&#xA;在 这个Tkinter案例中，ok和dialog是对窗口部件实例的引用，不是窗口部件实际的名字。因为Tk自身需要这些名字，Tkinter自动为每个新 窗口部件赋一个唯一的名字。在这个Tkinter案例中，这个dialog的名字或许类似&amp;rdquo;.1428748&amp;rdquo;，并且button可能 是&amp;rdquo;.1428748.1432920&amp;rdquo;。如果你希望得到一个Tkinter窗口部件的完整名字，你可以在这个窗口部件实例上使用str函数：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print str(ok)&#xA;.1428748.1432920&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果你确实需要为一个窗口部件指定一个名字，你可以在你创建这个窗口部件时使用name选项。你这么做的原因可能是你需要和用Tcl写的代码接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的例子将产生一个名为&amp;rdquo;.dialog.ok&amp;rdquo;的窗口部件（如果你忘了命名dialog,那么名字可能类似&amp;rdquo;.1428748.ok&amp;rdquo;）：&#xA;ok = Button(dialog, name=&amp;ldquo;ok&amp;rdquo;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为了避免与此同时Tkinter的名字机制相冲突，不要使用只包含数字的名字。同样注意name是只能创建一次的选项；一旦你创建了这个部件的名字，那么你就不能再改变它的名字了。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>python上手指南</title>
      <link>http://dashayu.tk/default/python%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</link>
      <pubDate>2014-11-27 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;资源列表：&#34; href=&#34;#资源列表：&#34;&gt;&lt;/a&gt;资源列表：&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;python&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://woodpecker.org.cn/abyteofpython_cn/chinese/&#34;&gt;简明 Python 教程&lt;/a&gt; 浅显易懂，快速上手&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/vamei/archive/2012/09/13/2682778.html&#34;&gt;Python快速教程&lt;/a&gt; 全。不过对新手会有点鸭梨&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.fenby.com/course/list/1022&#34;&gt;fenby&lt;/a&gt; 边学边练&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://study.163.com/course/courseMain.htm?courseId=302001&#34;&gt;一些可能会用到的模块&lt;/a&gt; 网易公开课&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/qiwsir/ITArticles/blob/master/BasicPython/index.md&#34;&gt;零基础学Python - 老齐&lt;/a&gt; 东西很全。缺点是太多啰嗦，基础部分适合文科生&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Tkinter&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.yiibai.com/python/python_gui_programming.html&#34;&gt;易百&lt;/a&gt; 全面、详细、图文演示&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;dajango&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://study.163.com/course/courseMain.htm?courseId=320022&#34;&gt;【网易公开课】快速上手&lt;/a&gt; 一个下午熟悉 Dajango&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;博客&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://maidoudao.iteye.com/category/173134&#34;&gt;Sun&lt;/a&gt; 很详细的学习笔记&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/articlelist_1797182715_4_1.html&#34;&gt;张哲的新浪博客&lt;/a&gt; 很全面&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;别人整理的资源列表&#34; href=&#34;#别人整理的资源列表&#34;&gt;&lt;/a&gt;别人整理的资源列表&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/Yixiaohan/codeparkshare&#34;&gt;github.com/Yixiaohan&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>cs203的那点事儿</title>
      <link>http://dashayu.tk/Boring Notes/cs203%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</link>
      <pubDate>2014-07-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这篇文章有三个标签&lt;code&gt;LXMP&lt;/code&gt; &lt;code&gt;Go&lt;/code&gt; &lt;code&gt;HUSTOJ&lt;/code&gt;，在我接管服务器以前，这三个东西我是一个也不知道的，靠着自己的不懈折腾，时隔大半年，收获颇丰。今夜不眠，拿出来聊聊。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;lamp&#34; href=&#34;#lamp&#34;&gt;&lt;/a&gt;LAMP&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这是&lt;code&gt;HUSTOJ&lt;/code&gt;的原始架构，我接管服务器的第一件事就是一周内搭好&lt;code&gt;oj&lt;/code&gt;，那一周我是在机房没日没夜的呆了几天，终于把我们自己的&lt;code&gt;oj&lt;/code&gt;给架起来了。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Linux&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果真的要找基础，就是大一下蹭在&lt;code&gt;KDE&lt;/code&gt;下生活过三个月，后来移居&lt;code&gt;OSX&lt;/code&gt;但是敲命令的习惯还是保留了下来。以至于至今没怎么好好的用过&lt;code&gt;Windows&lt;/code&gt;！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在最开始，很多人给我的建议就是&lt;code&gt;鸟哥的私房菜&lt;/code&gt;，天哪这么厚一本书我怎么可能几天内看完！所以在最开始的时候其实很简单，需要什么了就去百度就去&lt;code&gt;Google&lt;/code&gt;，查不到的就去问各路大神了。由于迁居&lt;code&gt;OSX&lt;/code&gt;导致一直没有踏踏实实地下来学习过&lt;code&gt;Linux&lt;/code&gt;，导致今日依旧小白一个。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Apache&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;最早接触这些东西是当年看哈佛的计算机公开课时提到的&lt;code&gt;XAMPP&lt;/code&gt;，然后一直用了它很久包括使用&lt;code&gt;Linux&lt;/code&gt;时在本地学HTML5依旧用得它。所以在这个时候格外吃力，都是去百度&lt;code&gt;Apache如何修改网站位置&lt;/code&gt; &lt;code&gt;Apache如何添加子域名&lt;/code&gt;之类白痴之极的问题，也曾立志去研习&lt;code&gt;Apache&lt;/code&gt;配置详解，后来由于你们猜得到的原因就没怎么碰过了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在&lt;code&gt;Linux&lt;/code&gt;下最喜欢的命令就是&lt;code&gt;apt-get&lt;/code&gt;，特别喜欢&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;upgrade&lt;/code&gt;的感觉。我曾两次&lt;code&gt;upgrade&lt;/code&gt;服务器，第一次出现了小问题一个下午搞定了，第二次依旧手贱，结果把&lt;code&gt;HUSTOJ&lt;/code&gt;的&lt;code&gt;Judged&lt;/code&gt;搞坏了，边被吐槽边修复了两三天（当时正值计算机学院在&lt;code&gt;OJ&lt;/code&gt;上做算法作业！）深感无力回天，不得已拿&lt;code&gt;Go&lt;/code&gt;重写了&lt;code&gt;Judged&lt;/code&gt;。由于积累了数天的重判任务于是就把判题端开到了十进程。。两三天的调试，至今运行良好。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;MySQL&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;其实对MySQL的熟悉完全是嘴表层最表层的，没有系统学过数据库理论，甚至连&lt;code&gt;SQL&lt;/code&gt;语法都没怎么学过，同样是遇到一个问题就去白痴地问一次。开发&lt;code&gt;oj&lt;/code&gt;时几乎也都是&lt;code&gt;copy&lt;/code&gt;-&lt;code&gt;paste&lt;/code&gt;照猫画虎过来的。后来学&lt;code&gt;Go&lt;/code&gt;时认识了&lt;code&gt;orm&lt;/code&gt;这类东西，从此对&lt;code&gt;SQL&lt;/code&gt;再没有去看了。早上看到一篇程序员等级，最低级的被成为&lt;code&gt;CRUD&lt;/code&gt;程序员，我估计我连这些都不算够格。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;PHP&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;PHP&lt;/code&gt;在这些东西是最早接触的，曾在&lt;code&gt;w3school&lt;/code&gt;上看过，但是由于上述知识的匮乏，其实跟没学一样（曾一度去琢磨php和js该学哪个），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;开发&lt;code&gt;oj&lt;/code&gt;时真正要用&lt;code&gt;php&lt;/code&gt;了那个时候一般我改一句代码&lt;code&gt;oj&lt;/code&gt;就会挂一次，经常被问得就是&lt;code&gt;今天&lt;/code&gt;oj&lt;code&gt;我怎么上着上着就上不去了过一会又好了！？&lt;/code&gt; &lt;code&gt;你是在作死！！！&lt;/code&gt;等等之类的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;庆幸毕竟是有压力在身上，学对&lt;code&gt;PHP&lt;/code&gt;还是学了点。也认识了很多，从语法灵活度来说PHP是多么简单的语言，但是在语法组织上你会觉得这是让人烦到死的东西。由于是&lt;code&gt;Python&lt;/code&gt; &lt;code&gt;Ruby&lt;/code&gt; &lt;code&gt;Go&lt;/code&gt; 等极简语法语言的崛起。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;go&#34; href=&#34;#go&#34;&gt;&lt;/a&gt;Go&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我为什么会走上&lt;code&gt;Go&lt;/code&gt;说来完全是打发寂寞，于是我就去网上看世界上有哪些语言，先被&lt;code&gt;python&lt;/code&gt; &lt;code&gt;ruby&lt;/code&gt; 这类轻巧的语言所吸引，又因为速度的传言转到了&lt;code&gt;NodeJS&lt;/code&gt;，暑假期间蹭用&lt;code&gt;HTML5&lt;/code&gt;写过一个游戏，我感觉到了&lt;code&gt;JS&lt;/code&gt;在某些方面的力不从心（当然一定是有解的只是感觉不那么优雅）。后来意外看到了&lt;code&gt;Go&lt;/code&gt;语言并被它深深地吸引。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;意外的是我的两个朋友哈工大的光光和电子科大的42大神都开始学&lt;code&gt;Go&lt;/code&gt;。回过头看那个时候正是一些东西在国内迅猛发展的时期，&lt;code&gt;Astaxie&lt;/code&gt;、&lt;code&gt;UnKnwon&lt;/code&gt;等大神开始大力推广&lt;code&gt;Go&lt;/code&gt;，&lt;code&gt;MongoDB&lt;/code&gt;当时还算最火的，当时&lt;code&gt;SSDB&lt;/code&gt;貌似还没出来的说。当时我周围的学长们大多都不知道这是些什么玩意。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在那个时候几列火车从我身边高速驶过，我不知道我是否属于这些列车，但是我知道，这些列车都将开往未来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;nginx&#34; href=&#34;#nginx&#34;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;由于某些历史原因使得我成了在很多方面有强迫症的人，很多方面都试图用最好的且不惜成本，浏览器、编辑器、播放器甚至输入法、日历等几乎所有类型的工具我都要做个横向对比找出最顺手的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器软件也不例外，不知道被谁忽悠了&lt;code&gt;Nginx&lt;/code&gt;远远优于&lt;code&gt;Apache&lt;/code&gt;。下定决心要进入&lt;code&gt;Nginx&lt;/code&gt;的世界，从&lt;code&gt;LNMP&lt;/code&gt;的搭建、配置这些基本的学起，到后来需要高级功能时已不再使用&lt;code&gt;Apache&lt;/code&gt;，后来学了&lt;code&gt;Go&lt;/code&gt;，对&lt;code&gt;pass&lt;/code&gt; &lt;code&gt;rewrite&lt;/code&gt;要求多了就再没离开过&lt;code&gt;Nginx&lt;/code&gt;了。但是说时候这个环境比&lt;code&gt;LAMP&lt;/code&gt;复杂多了大概最开始的几次每次都出小问题，多配几次才可以顺利地搞下来。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;hustoj&#34; href=&#34;#hustoj&#34;&gt;&lt;/a&gt;HUSTOJ&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;HUSTOJ&lt;/code&gt;的代码写得极其简单随意，像我这种没有软件工程基础的人大概花了不到一天的功夫就搞懂了它的大概框架，改起来自然也是得心应手，越来后来一些问题也越来越明显：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;代码清晰度有待提高，大框架简单，细节上自然要复杂多了。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在做二次开发时每次的思路的很简单，但工作量甚大，譬如&lt;code&gt;user&lt;/code&gt;改一个字段，你就得把所有&lt;code&gt;select&lt;/code&gt;了&lt;code&gt;user&lt;/code&gt;的页面代码全部修改，还得边改边调试。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;从这几方面来讲随着需求越来越高，一直二次开发下去是个很不明智的做法，所以有必要规划一套适合各种复杂情况的在线编程学习平台。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;庆幸我正好在学&lt;code&gt;Go&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果把&lt;code&gt;HUSTOJ&lt;/code&gt;分为三块，&lt;code&gt;Web&lt;/code&gt; &lt;code&gt;Judged&lt;/code&gt; &lt;code&gt;Judge_client&lt;/code&gt;。前两部分基本已经用&lt;code&gt;Go&lt;/code&gt;重写。其中&lt;code&gt;Judged&lt;/code&gt;已经在服务器上正常使用半年，目前运行良好。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;最后&#34; href=&#34;#最后&#34;&gt;&lt;/a&gt;最后&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;之前在做&lt;code&gt;OJ&lt;/code&gt;的时候我就考虑一个问题，如果要比做&lt;code&gt;OJ&lt;/code&gt;，那我永远做不过杭电，结合自己的教育梦，我希望能一步一步打造一个在线编程教育平台。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Mac - tips</title>
      <link>http://dashayu.tk/default/Mac---tips/</link>
      <pubDate>2014-07-01 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;网络服务&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;查看端口占用&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>hello, gor</title>
      <link>http://dashayu.tk/Boring Notes/hello%2C-gor/</link>
      <pubDate>2014-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;既然来了，就说说为什么来吧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;今天是个比较兴奋地日子，因为我的新显示器（&lt;a href=&#34;http://item.jd.com/933422.html&#34;&gt;AOC LV242WEM&lt;/a&gt;）终于到了，一下子就喜欢上了新屏幕，敞亮、饱和、逼真、鲜艳，反正就是棒极了！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;稀里糊涂就想试试拿 gor 在 github.io 上搭个博客了，说实话阿里的服务器即将到期没有资本也木有必要去续费。github.io 却看起来可以永存。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用几分钟后&#34; href=&#34;#使用几分钟后&#34;&gt;&lt;/a&gt;使用几分钟后&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;从 gor 的使用到github.io，到各种配置，官网都有很详细的说明我就不再赘述了。也可以看我的&lt;a href=&#34;2013/new-born.html&#34;&gt;第一篇&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;DISQUS广告&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;拿到这个博客你首先得干的第一件事应该就是去除评论框该死的广告！在&lt;code&gt;widgets/comments/config.yml&lt;/code&gt;里，把&lt;code&gt;short_name&lt;/code&gt;改成你自己的，如果没有怎么办？可以选择去建一个（也可以有一个快速去广告的办法就是乱加几个字母，这样首先就没有广告了），建的时候有一大堆对勾要选注意其中有一个&lt;code&gt;发现&lt;/code&gt;，果断去掉。然后更新&lt;code&gt;short_name&lt;/code&gt;就ok了&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;换成多说评论框&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;多说是在国内用的还算比较多的一个，所以把disqus替换成多说也是个很好的想法，置于怎么替换，下次再说。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;题外话&#34; href=&#34;#题外话&#34;&gt;&lt;/a&gt;题外话&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;MacDown&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这是一个看起来特别棒的markdown编辑器，堪比&lt;code&gt;CMD Markdown&lt;/code&gt;但是看起来不是偏离Markdown那么离谱。但是只支持Mac平台。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好了该说说这个博客要干嘛了。由于在github上，所以考虑还是技术为主吧。如果搞得还行，把抽风系列挂过来也不错~&lt;/p&gt;&#xA;&#xA;&lt;p&gt;就这样了，还得睡觉。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>About Me</title>
      <link>http://dashayu.tk/default/About-Me/</link>
      <pubDate>2014-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;爱生活，爱思考&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;兴趣爱好&#34; href=&#34;#兴趣爱好&#34;&gt;&lt;/a&gt;兴趣爱好&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编程技术&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序设计&lt;/li&gt;&#xA;&lt;li&gt;服务端开发&lt;/li&gt;&#xA;&lt;li&gt;前段折腾&lt;/li&gt;&#xA;&lt;li&gt;嵌入式探索&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;社交网络&#34; href=&#34;#社交网络&#34;&gt;&lt;/a&gt;社交网络&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://weibo.com/u/2409424241&#34;&gt;Weibo&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/nian.lao&#34;&gt;Facebook&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/micln&#34;&gt;Github&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://coding.net/u/kzzhr&#34;&gt;Coding.net&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;献丑集&#34; href=&#34;#献丑集&#34;&gt;&lt;/a&gt;献丑集&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;2011&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;KJO：基于&lt;code&gt;vs2010&lt;/code&gt;的OI题库管理系统。这是高一时&lt;code&gt;第一次在无人指导下完成&lt;/code&gt;的作品。&lt;/li&gt;&#xA;&lt;li&gt;《*r*m*ife》：不忍直视的3D动画&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;2012&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;康杰中学3D模型：&lt;code&gt;3DsMAX&lt;/code&gt;建模学习&lt;/li&gt;&#xA;&lt;li&gt;坦克大战游戏：&lt;code&gt;HTML5&lt;/code&gt;初体验&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;2013&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/micln/ArmGo&#34;&gt;ArmGo&lt;/a&gt;：通过设计程序指令来控制机械臂。基于&lt;code&gt;HTML5&lt;/code&gt;，参照&lt;code&gt;cargo-bot&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;[uscoj]()：基于HUSTOJ二次开发的在线评测系统。纯属为了交差&lt;/li&gt;&#xA;&lt;li&gt;uoj：基于&lt;code&gt;beego&lt;/code&gt;的在线程序评测系统，原想重写OJ，结果。。已残废&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;2014&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[博客前段]()：前段练习&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://coding.net/u/kzzhr/p/ztalk/git&#34;&gt;ztalk&lt;/a&gt;：精简结构却不失强大的论坛系统，主要是为了练习&lt;code&gt;beego&lt;/code&gt;，为 xxx 打基础&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://coding.net/u/kzzhr/p/zqn/git&#34;&gt;zqn&lt;/a&gt;: 简单好用的七牛Go库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>你的第一篇博客</title>
      <link>http://dashayu.tk/2013/new-born.html</link>
      <pubDate>2013-02-08 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;感谢你使用Gor编写博客&lt;/h3&gt;&#xA;&#xA;&lt;h3&gt;本文位于 posts/first-blog.md , 你可以任意删掉,修改这个文件&lt;/h3&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
    <item>
      <title>acmtips</title>
      <link>http://dashayu.tk/default/acmtips/</link>
      <pubDate>2012-10-08 12:00:00 +0800</pubDate>
      <description>&lt;div&gt;&#xA;&#xA;    &lt;div id=&#39;Directory&#39;&gt;&lt;/div&gt;&#xA;    &lt;script&gt;&#xA;    &#xA;        var tt = [&#34;&#34;, &#34;一&#34;, &#34;二&#34;, &#34;三&#34;, &#34;四&#34;, &#34;五&#34;, &#34;六&#34;, &#34;七&#34;, &#34;八&#34;, &#34;九&#34;, &#34;十&#34;];&#xA;        var tq = [&#34;&#34;, &#34;①&#34;, &#34;②&#34;, &#34;③&#34;, &#34;④&#34;, &#34;⑤&#34;, &#34;⑥&#34;, &#34;⑦&#34;, &#34;⑧&#34;, &#34;⑨&#34;, &#34;⑩&#34;];&#xA;&#xA;        window.onload = function(){&#xA;            return;&#xA;            h1 = document.querySelectorAll(&#34;h1&#34;);           h2 = document.querySelectorAll(&#34;h2&#34;);           h3 = document.querySelectorAll(&#34;h3&#34;);           h4 = document.querySelectorAll(&#34;h4&#34;);&#xA;            &#xA;            var txt = &#34;&lt;h2&gt; Directory &lt;/h2&gt;&#34;;&#xA;            txt += &#34;&lt;pre&gt;&#34;&#xA;            for ( t1=0; t1&lt;h1.length; t1++ ){&#xA;                txt += &#34;&lt;h3&gt;&#34; + (tt[t1+1]) + &#34;.&#34; + h1[t1].innerHTML + &#34;&lt;/h3&gt;&#34;;&#xA;                for ( t2=0; t2&lt;h2.length; t2++ ) if (h2[t2].offsetTop &gt; h1[t1].offsetTop &amp;&amp; ( t1==h1.length-1 ||  h2[t2].offsetTop &lt; h1[t1+1].offsetTop )) {&#xA;                    txt += &#34;&lt;h4&gt;   &#34; + (t2+1) + &#34;. &#34; + h2[t2].innerHTML + &#34;&lt;/h4&gt;&#34;;&#xA;                    for (t3=0; t3&lt;h3.length; t3++ ) if (h3[t3].offsetTop &gt; h2[t2].offsetTop &amp;&amp; ( t2==h2.length-1 ||  h3[t3].offsetTop &lt; h2[t2+1].offsetTop )) {&#xA;                        txt += &#34;&lt;h5&gt;       &#34; + (t3+1) + &#34;) &#34; + h3[t3].innerHTML + &#34;&lt;/h5&gt;&#34;;&#xA;                        for ( t4=0; t4&lt;h4.length; t4++ ) if (h4[t4].offsetTop &gt; h3[t3].offsetTop &amp;&amp; ( t3==h3.length-1 ||  h4[t4].offsetTop &lt; h3[t3+1].offsetTop )) {&#xA;                            txt += &#34;         | &#34; + h4[t4].innerHTML + &#34;\n&#34;;&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;            txt += &#34;&lt;/pre&gt;&#34;;&#xA;            document.getElementById(&#34;Directory&#34;).innerHTML = txt;&#xA;        }&#xA;    &lt;/script&gt;&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;acm语法基础&#34; href=&#34;#acm语法基础&#34;&gt;&lt;/a&gt;ACM语法基础&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;c/cpp不常用的知识点&#34; href=&#34;#c/cpp不常用的知识点&#34;&gt;&lt;/a&gt;C/CPP不常用的知识点&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;字符串拆分&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;char ss[] = &amp;quot;(1,2,3,4)&amp;quot;;&#xA;char *p = strtok(ss, &amp;quot;(,)&amp;quot;);&#xA;for (int i(1); i&amp;lt;=n; i++) {&#xA;    sscanf(p, &amp;quot;%d&amp;quot;, &amp;amp;k);&#xA;    p = strtok(NULL, &amp;quot;,)&amp;quot;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;gets 、fgets 、getline&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gets 会过滤行首空格（不含&lt;code&gt;\n&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;li&gt;fgets 完全读入，把&lt;code&gt;\n&lt;/code&gt;吃进字符串末位，与scanf混用时容易出错&lt;/li&gt;&#xA;&lt;li&gt;getline 自动跳转下一行，不会过滤行首空格&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java快速读写&#34; href=&#34;#java快速读写&#34;&gt;&lt;/a&gt;Java快速读写&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;例题&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;@ hdoj 5047 Sawtooth&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;读入一个大数，按照特定公式计算结果。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;import java.math.*;  &#xA;import java.util.*;  &#xA;import java.io.*;  &#xA;  &#xA;public class Main {  &#xA;    public static void main(String[] args) throws Exception {  &#xA;          &#xA;        BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));    &#xA;        BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));  &#xA;          &#xA;        BigInteger n, ans, a1, a2, a7, a8;  &#xA;        a1 = BigInteger.valueOf(1);  &#xA;        a2 = BigInteger.valueOf(2);  &#xA;        a7 = BigInteger.valueOf(7);  &#xA;        a8 = BigInteger.valueOf(8);  &#xA;          &#xA;        String ss = cin.readLine();  &#xA;        int T = Integer.parseInt(ss);  &#xA;          &#xA;        for(int i=1; i&amp;lt;=T; i++){  &#xA;            ss = cin.readLine();  &#xA;            n = new BigInteger( ss );  &#xA;            cout.write( &amp;quot;Case #&amp;quot;+i+&amp;quot;: &amp;quot; );  &#xA;              &#xA;            ans = n.multiply(n).multiply(a8);  &#xA;            ans = ans.subtract(a7.multiply(n));  &#xA;            ans = ans.add(a1);  &#xA;              &#xA;            cout.write( ans.toString() );  &#xA;            cout.newLine();  &#xA;            cout.flush();  &#xA;        }  &#xA;  &#xA;    }  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;模拟易错点&#34; href=&#34;#模拟易错点&#34;&gt;&lt;/a&gt;模拟易错点&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;a&#34; href=&#34;#a&#34;&gt;&lt;/a&gt;a&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;b&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;@ POJ 1017 Packets | 装完大包装小包&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;6种物品，体积分别为1*1 2*2 ... 6*6 。每种数量有20000&#xA;包裹体积为6*6，问装满所有的物品至少需要多少个包裹。&#xA;solution：&#xA;从大到小装，有缝隙了依次选小的。&#xA;*/&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;int n=6,t;&#xA;int a[8];&#xA;int push(int t,int i, int num){             // 把num个a[i]放进容量为t的箱子里，返回箱子容量&#xA;    if ( num &amp;gt; a[i]) num = a[i];&#xA;    t -= i*i * num;&#xA;    a[i] -= num;&#xA;    return t;&#xA;}&#xA;int main(){&#xA;    for(;;){&#xA;        int ts = 0;&#xA;        for ( int i(1);i&amp;lt;=n;i++){&#xA;            cin &amp;gt;&amp;gt; a[i];&#xA;            ts+=a[i];&#xA;        }&#xA;        if (!ts) break;&#xA;&#xA;        int s =a[6]+a[5]+a[4];&#xA;&#xA;        // a5&#xA;        if (a[5]*11 &amp;gt;= a[1]) a[1] = 0;&#xA;        else a[1] -= a[5]*11;&#xA;&#xA;        // a4&#xA;        for ( int i(1);i&amp;lt;=a[4];i++){&#xA;            t = push(20,2,5);&#xA;            if (t) t = push(t,1,t);&#xA;        }&#xA;&#xA;        // a3&#xA;        s += a[3] / 4;      // 整装3&#xA;        a[3] %= 4;&#xA;        if (a[3]){                                  //  剩下的空间分情况装2&#xA;            t = 36 - a[3]*9;&#xA;            if ( a[3] == 1 ) t = push(t,2,5);&#xA;            if ( a[3] == 2 ) t = push(t,2,3);&#xA;            if ( a[3] == 3 ) t = push(t,2,1);&#xA;            if (t) t = push(t,1,t);                     //  剩下的空间都装1&#xA;            s++;&#xA;        }&#xA;&#xA;        // a2&#xA;        s += a[2] / 9;&#xA;        a[2] %= 9;&#xA;        if (a[2]){&#xA;            t = 36 - a[2] * 4;&#xA;            t = push(t,1,t);&#xA;            s++;&#xA;        }&#xA;&#xA;        // a1&#xA;        s += a[1] / 36;&#xA;        a[1] %= 36;&#xA;        if (a[1]) s++;&#xA;&#xA;        cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;@ USACO 1.4.3 The Clocks&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;根据九个表和九个操作的关系，得出下列关系表：&#xA;先列一下钟表与矩阵的关系图：&#xA;Ci = C[i] / 3; &#xA;clocks  operates&#xA;1   1 2 4       ( C1 + p1 + p2 + p4 ) % 4 == 0&#xA;2   1 2 3 5     ( C2 + p1 + p2 + p3 + p5 ) % 4 == 0 &#xA;3   2 3 6       ...&#xA;4   1 4 5 7     ...&#xA;5   1 3 5 7 9   ...&#xA;6   3 5 6 9 &#xA;7   4 7 8&#xA;8   5 7 8 9&#xA;9   6 8 9&#xA;&#xA;把上面的关系式反过来，就能在已知 c[i] 通过枚举部分 pi 求出其它 pi &#xA;我枚举的是123三个操作，然后剩下6个操作就可以就确定了。&#xA;*/&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;int c[11];&#xA;int cal(int a, int b, int c){&#xA;    int t =  - a - b - c;&#xA;    while ( t &amp;lt; 0 ) t += 4;&#xA;    return t;&#xA;}&#xA;int cal(int a, int b, int c, int d){&#xA;    int t =  - a - b - c - d;&#xA;    while ( t &amp;lt; 0 ) t += 4;&#xA;    return t;&#xA;}&#xA;int main(){&#xA;    freopen(&amp;quot;clocks.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);&#xA;    freopen(&amp;quot;clocks.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);&#xA;    for (int i(1);i&amp;lt;=9;i++) {&#xA;        cin &amp;gt;&amp;gt; c[i];&#xA;        c[i] /= 3;&#xA;    }&#xA;    int p[11];&#xA;    bool found = false;&#xA;    for ( p[1] = 0; p[1] &amp;lt; 4; p[1]++ ){&#xA;        for ( p[2] = 0; p[2] &amp;lt; 4; p[2]++ ){&#xA;            for ( p[3] = 0; p[3] &amp;lt; 4; p[3]++ ){&#xA;                p[4] = cal(c[1], p[1], p[2]);&#xA;                p[5] = cal(c[2], p[1], p[2], p[3]);&#xA;                p[6] = cal(c[3], p[2], p[3]);&#xA;                p[7] = cal(c[4], p[1], p[4], p[5]);&#xA;                p[8] = cal(c[7], p[4], p[7]);&#xA;                p[9] = cal(c[9], p[6], p[8]);&#xA;                if (((c[5] + p[1] + p[3] + p[5] + p[7] + p[9]) % 4 == 0) &amp;amp;&amp;amp;&#xA;                    ((c[8] + p[5] + p[7] + p[8] + p[9] ) % 4 == 0) &amp;amp;&amp;amp;&#xA;                    ((c[6] + p[3] + p[5] + p[6] + p[9] ) % 4 == 0 )){&#xA;                    found = 1;&#xA;                    break;&#xA;                }&#xA;                if ( found ) break;&#xA;            }&#xA;            if ( found ) break;&#xA;        }&#xA;        if ( found ) break;&#xA;    }&#xA;    int i = 1;&#xA;    while ( p[i] == 0 ) i++;&#xA;    printf(&amp;quot;%d&amp;quot;,i);&#xA;    p[i--]--;&#xA;    while ( ++i &amp;lt;= 9 ) while ( p[i]-- ) printf(&amp;quot; %d&amp;quot;,i);&#xA;    printf(&amp;quot;\n&amp;quot;);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;搜索&#34; href=&#34;#搜索&#34;&gt;&lt;/a&gt;搜索&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;多状态标记&#34; href=&#34;#多状态标记&#34;&gt;&lt;/a&gt;多状态标记&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;@ HDU 5024 Wang Xifeng&amp;rsquo;s Little Plot 广州区域赛&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;题意：找到一个最长的L型&#xA;思路：把L拆成两个直线，枚举所有的情况，记忆化搜索&#xA;*/&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#include &amp;lt;algorithm&amp;gt;&#xA;using namespace std;&#xA;const int maxn = 110;&#xA;&#xA;int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};&#xA;int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};&#xA;int n, f[maxn][maxn][8];&#xA;char g[maxn][maxn];&#xA;&#xA;int dfs(int x, int y, int dir) {&#xA;    if (f[x][y][dir] != -1)&#xA;        return f[x][y][dir];&#xA;&#xA;    if (g[x+dx[dir]][y+dy[dir]] == &#39;.&#39;)&#xA;        return f[x][y][dir] = 1 + dfs(x+dx[dir], y+dy[dir], dir);&#xA;    else return f[x][y][dir] = 1;&#xA;}&#xA;&#xA;int main() {&#xA;    while (scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) != EOF &amp;amp;&amp;amp; n) {&#xA;        memset(f, -1, sizeof(f));&#xA;        memset(g, 0, sizeof(g));&#xA;        for (int i = 1; i &amp;lt;= n; i++)&#xA;            scanf(&amp;quot;%s&amp;quot;, g[i]+1);&#xA;&#xA;        int ans = -1;&#xA;        for (int i = 1; i &amp;lt;= n; i++)&#xA;            for (int j = 1; j &amp;lt;= n; j++) &#xA;                if (g[i][j] == &#39;.&#39;) {&#xA;                    ans = max(ans, dfs(i, j, 0) + dfs(i, j, 2) - 1);&#xA;                    ans = max(ans, dfs(i, j, 1) + dfs(i, j, 2) - 1);&#xA;                    ans = max(ans, dfs(i, j, 1) + dfs(i, j, 3) - 1);&#xA;                    ans = max(ans, dfs(i, j, 0) + dfs(i, j, 3) - 1);&#xA;                    ans = max(ans, dfs(i, j, 4) + dfs(i, j, 5) - 1);&#xA;                    ans = max(ans, dfs(i, j, 4) + dfs(i, j, 6) - 1);&#xA;                    ans = max(ans, dfs(i, j, 7) + dfs(i, j, 5) - 1);&#xA;                    ans = max(ans, dfs(i, j, 7) + dfs(i, j, 6) - 1);&#xA;                }&#xA;        printf(&amp;quot;%d\n&amp;quot;, ans);&#xA;    }   &#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;@ HDU 5025 Saving Tang Monk&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;题意：给一个地图，孙悟空(K)救唐僧(T)，地图中&amp;rsquo;S&amp;rsquo;表示蛇，第一次到这要杀死蛇（蛇最多5条），多花费一分钟，&amp;rsquo;1&amp;rsquo;~&amp;rsquo;m&amp;rsquo;表示m个钥匙(m&amp;lt;=9)，孙悟空要依次拿到这m个钥匙，然后才能去救唐僧，集齐m个钥匙之前可以经过唐僧，集齐x个钥匙以前可以经过x+1,x+2..个钥匙，问最少多少步救到唐僧。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;本题主要是每一条蛇状态的记录，使用状态压缩，将每一条蛇的状态用二进制位记录下来，1代表活，0代表死。&#xA;使用vis四维数组记录每一点走过的状态，x,y分别表示位置，k 钥匙，s 表示蛇的状态，b 表示步数。&#xA;*/&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;algorithm&amp;gt;&#xA;#include &amp;lt;cmath&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#include &amp;lt;queue&amp;gt;&#xA;#include &amp;lt;stack&amp;gt;&#xA;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;set&amp;gt;&#xA;#include &amp;lt;map&amp;gt;&#xA;const int inf=0xfffffff;&#xA;typedef long long ll;&#xA;using namespace std;&#xA;&#xA;char m[105][105];&#xA;int vis[105][105][15][40];&#xA;int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};&#xA;int sx, sy, sn, N, M;&#xA;struct node&#xA;{&#xA;    int x, y, k, s, b;&#xA;};&#xA;queue&amp;lt;node&amp;gt; q;&#xA;int ans;&#xA;&#xA;void bfs()&#xA;{&#xA;    node now;&#xA;    q.push((node){sx, sy, 0, 0, 0});&#xA;    while(!q.empty()){&#xA;        now = q.front();&#xA;        q.pop();&#xA;        int x = now.x, y = now.y, k = now.k, s = now.s, b = now.b;&#xA;        if(k == M &amp;amp;&amp;amp; m[x][y] == &#39;T&#39;){&#xA;            ans = min(ans, b);&#xA;        }&#xA;&#xA;        if(vis[x][y][k][s] != 0) continue;&#xA;        vis[x][y][k][s] = 1;&#xA;&#xA;        for(int i = 0; i &amp;lt; 4; i ++){&#xA;            int nx = x + dx[i], ny = y + dy[i];&#xA;            int snn = m[nx][ny] - &#39;A&#39;;&#xA;&#xA;            if(snn &amp;gt;= 0 &amp;amp;&amp;amp; snn &amp;lt; sn){&#xA;                if((1&amp;lt;&amp;lt;snn) &amp;amp; s) q.push((node) {nx, ny, k, s, b + 1});&#xA;                else q.push((node) {nx, ny, k,  (1&amp;lt;&amp;lt;snn) | s, b + 2});&#xA;            }&#xA;            else{&#xA;                if(m[nx][ny] == k + &#39;1&#39;){&#xA;                    q.push((node) {nx, ny, k + 1, s, b + 1});&#xA;                }&#xA;                else if(nx &amp;gt; 0 &amp;amp;&amp;amp; nx &amp;lt;= N &amp;amp;&amp;amp; ny &amp;gt; 0 &amp;amp;&amp;amp; ny &amp;lt;= N &amp;amp;&amp;amp; m[nx][ny] != &#39;#&#39;)&#xA;                    q.push((node) {nx, ny, k, s, b + 1});&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;int main()&#xA;{&#xA;    //freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin);&#xA;    while(~scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;N, &amp;amp;M)){&#xA;        if(N == 0 &amp;amp;&amp;amp; M == 0) break;&#xA;        memset(m, 0, sizeof(m));&#xA;        memset(vis, 0, sizeof(vis));&#xA;        sn = 0;&#xA;        for(int i = 1; i &amp;lt;= N; i ++){&#xA;            scanf(&amp;quot;%s&amp;quot;, m[i] + 1);&#xA;            for(int j = 1; j &amp;lt;= N; j ++){&#xA;                if(m[i][j] == &#39;K&#39;){&#xA;                    sx = i;&#xA;                    sy = j;&#xA;                }&#xA;                if(m[i][j] == &#39;S&#39;){&#xA;                    m[i][j] = &#39;A&#39; + sn;&#xA;                    sn ++;&#xA;                }&#xA;            }&#xA;        }&#xA;        ans = inf;&#xA;        bfs();&#xA;        if(ans == inf) printf(&amp;quot;impossible\n&amp;quot;);&#xA;        else printf(&amp;quot;%d\n&amp;quot;, ans);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;解法：BFS，每个节点维护四个值：&#xA;x,y ： 当前坐标&#xA;key ：已经集齐了key个钥匙&#xA;step：已经走了多少步&#xA;S ：   蛇的访问状态 (2^5的数表示，某位为1表示已经杀过了)&#xA;然后把唐僧看做钥匙m+1，再加点优化：&#xA;为了避免超时，用一个全局的dis[x][y][key][S] 表示到(x,y),已经集齐到key个钥匙，蛇的访问状态为S时的最小步数，如果BFS扩展的时候，当前状态的步数&amp;gt;=dis[当前状态]，那么就不再扩展下去了。&#xA;BFS中的逻辑就很简单了，看代码吧。&#xA;最后，枚举蛇的状态S，取dis[x][y][m+1][S]的最小值即为最小步数。&#xA;*/&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;#include &amp;lt;cmath&amp;gt;&#xA;#include &amp;lt;algorithm&amp;gt;&#xA;#include &amp;lt;queue&amp;gt;&#xA;#include &amp;lt;map&amp;gt;&#xA;#define INF 0x3f3f3f3f&#xA;using namespace std;&#xA;#define N 1000007&#xA;&#xA;int dis[104][104][12][33],Stot,M;&#xA;struct node&#xA;{&#xA;    int x,y,key,step,S;&#xA;};&#xA;int dx[4] = {0,0,1,-1};&#xA;int dy[4] = {1,-1,0,0};&#xA;map&amp;lt;pair&amp;lt;int,int&amp;gt;,int&amp;gt; snake;&#xA;char ss[105][105];&#xA;int n,m;&#xA;&#xA;bool OK(int nx,int ny)&#xA;{&#xA;    if(nx &amp;lt; n &amp;amp;&amp;amp; nx &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; n &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; ss[nx][ny] != &#39;#&#39;)&#xA;        return true;&#xA;    return false;&#xA;}&#xA;&#xA;void bfs(node s)&#xA;{&#xA;    queue&amp;lt;node&amp;gt; que;&#xA;    que.push(s);&#xA;    while(!que.empty())&#xA;    {&#xA;        node now = que.front();&#xA;        que.pop();&#xA;        int nx = now.x, ny = now.y;&#xA;        int key = now.key, step = now.step;&#xA;        int S = now.S;&#xA;        node tmp;&#xA;        for(int k=0;k&amp;lt;4;k++)&#xA;        {&#xA;            int kx = nx + dx[k];&#xA;            int ky = ny + dy[k];&#xA;            if(!OK(kx,ky)) continue;&#xA;            tmp.x = kx,tmp.y = ky;&#xA;            if(ss[kx][ky] == &#39;S&#39;)                    //蛇&#xA;            {&#xA;                int ind = snake[make_pair(kx,ky)];   //是第几条蛇&#xA;                tmp.key = key;&#xA;                if(S &amp;amp; (1&amp;lt;&amp;lt;(ind-1)))                 //如果已经杀死&#xA;                {&#xA;                    tmp.S = S;&#xA;                    tmp.step = step+1;&#xA;                } &#xA;                else                                 //否则要杀&#xA;                {&#xA;                    tmp.S = S|(1&amp;lt;&amp;lt;(ind-1));&#xA;                    tmp.step = step+2;&#xA;                }&#xA;                if(tmp.step &amp;lt; dis[kx][ky][tmp.key][tmp.S])&#xA;                {&#xA;                    dis[kx][ky][tmp.key][tmp.S] = tmp.step;&#xA;                    que.push(tmp);&#xA;                }&#xA;            }&#xA;            else if(ss[kx][ky] &amp;gt;= &#39;1&#39; &amp;amp;&amp;amp; ss[kx][ky] &amp;lt;= &#39;9&#39;)  //钥匙点&#xA;            {&#xA;                int num = ss[kx][ky] - &#39;0&#39;;&#xA;                tmp.step = step+1;&#xA;                tmp.S = S;&#xA;                if(num == key+1)                             //正好是要拿的那个&#xA;                    tmp.key = key+1;&#xA;                else&#xA;                    tmp.key = key;&#xA;                if(tmp.step &amp;lt; dis[kx][ky][tmp.key][tmp.S])&#xA;                {&#xA;                    dis[kx][ky][tmp.key][tmp.S] = tmp.step;&#xA;                    que.push(tmp);&#xA;                }&#xA;            }&#xA;            else if(ss[kx][ky] == &#39;$&#39;)   //唐僧这个点&#xA;            {&#xA;                tmp.key = key;&#xA;                tmp.S = S;&#xA;                tmp.step = step+1;&#xA;                if(M == key+1)           //已经集齐了所有钥匙，不再扩展，更新dis即可&#xA;                    dis[kx][ky][M][S] = min(dis[kx][ky][M][S],step+1);&#xA;                else                     //没有集齐，继续走&#xA;                    que.push(tmp);&#xA;            }&#xA;            else if(ss[kx][ky] == &#39;.&#39;)&#xA;            {&#xA;                tmp.key = key;&#xA;                tmp.S = S;&#xA;                tmp.step = step+1;&#xA;                if(tmp.step &amp;lt; dis[kx][ky][tmp.key][tmp.S])&#xA;                {&#xA;                    dis[kx][ky][tmp.key][tmp.S] = tmp.step;&#xA;                    que.push(tmp);&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    int Sx,Ex,Sy,Ey;&#xA;    int i,j;&#xA;    while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)!=EOF &amp;amp;&amp;amp; n+m)&#xA;    {&#xA;        if(n == 1)&#xA;        {&#xA;            puts(&amp;quot;impossible&amp;quot;);&#xA;            continue;&#xA;        }&#xA;        snake.clear();&#xA;        Stot = 0;&#xA;        M = m+1;&#xA;        for(i=0;i&amp;lt;n;i++)&#xA;        {&#xA;            scanf(&amp;quot;%s&amp;quot;,ss[i]);&#xA;            for(j=0;j&amp;lt;n;j++)&#xA;            {&#xA;                if(ss[i][j] == &#39;K&#39;)&#xA;                    Sx = i,Sy = j, ss[i][j] = &#39;.&#39;;&#xA;                else if(ss[i][j] == &#39;T&#39;)&#xA;                    Ex = i,Ey = j, ss[i][j] = &#39;$&#39;;&#xA;                else if(ss[i][j] == &#39;S&#39;)&#xA;                    snake[make_pair(i,j)] = ++Stot;&#xA;            }&#xA;        }&#xA;        node tmp;&#xA;        tmp.x = Sx,tmp.y = Sy,tmp.key = 0,tmp.step = 0,tmp.S = 0;&#xA;        memset(dis,INF,sizeof(dis));&#xA;        dis[Sx][Sy][0][0] = 0;&#xA;        bfs(tmp);&#xA;        int mini = INF;&#xA;        for(i=0;i&amp;lt;(1&amp;lt;&amp;lt;Stot);i++)&#xA;            mini = min(mini,dis[Ex][Ey][M][i]);&#xA;        if(mini == INF)&#xA;            puts(&amp;quot;impossible&amp;quot;);&#xA;        else&#xA;            printf(&amp;quot;%d\n&amp;quot;,mini);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;图论&#34; href=&#34;#图论&#34;&gt;&lt;/a&gt;图论&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;欧拉回路-哈密顿回路&#34; href=&#34;#欧拉回路-哈密顿回路&#34;&gt;&lt;/a&gt;欧拉回路 哈密顿回路&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;判断存在&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;判断欧拉通路：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个有向图存在欧拉回路必定也存在欧拉通路&amp;hellip;因为通路的定义包括了回路&lt;/li&gt;&#xA;&lt;li&gt;不考虑为欧拉回路的情况..一个有向图是欧拉通路就必须有一个点出度-入度=1,一个点入度-出度=1..这两点就是欧拉通路的起点和终点..并且该图连通&lt;/li&gt;&#xA;&lt;li&gt;我自己加一条，其实是对2的理解：入读-出度&amp;gt;1 时直接return false ，排除 a-&amp;gt;b a-&amp;gt;c 这种情况&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;判断欧拉回路：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;无向图是欧拉图的充要条件是所有点的度为偶数并且所有点联通&lt;br /&gt;&#xA;有向图是欧拉图的充要条件是所有点的入度=出度..并且联通&amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;判断连通:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;dfs遍历，这里有一份参考代码不过我一直怀疑其正确性。因为你无法确定有向图的起点，比如 a-&amp;gt;b-&amp;gt;c 如果你从b点开始搜的话就会悲催，但是你不知道b点上面还有没有点。&lt;/li&gt;&#xA;&lt;li&gt;并查集，并查集的方便之处不用废话。但是在图论中两点之间有多条边时需要注意一些细节的处理。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;关于判断入读出度:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一种办法是分别记录 in[] out[]&#xA;我用的办法是一个数组：sz[x]++ 表示拉出一条边，sz[x]&amp;ndash;表示走来一条边，sz[x]==1 sz[x]==-1 就是上面的两种情况&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;@ UVa 10129 Play on Words&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;题意就是给你一堆单词，按首位顺序排列起来，问你有没有解。&#xA;第一眼看上去是个哈密顿通路，单词当做节点，首尾关系作边，听上去妥妥的不过N有100000 复杂度太恐怖。&#xA;其实是从刘汝佳的小白书第二版（其实该叫小紫红书了）上欧拉回路那节看到的，所以得考虑考虑转换&#xA;把单词当边，首尾字符当做点 题目就转变为 欧拉通路&#xA;*/&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#define N 101010&#xA;using namespace std;&#xA;&#xA;int sz[333];&#xA;int fa[333];&#xA;bool ok[333];   //  数据中使用到的单词&#xA;int n, T;&#xA;&#xA;int getfa(int v)&#xA;{&#xA;    if ( fa[v] == v ) return v;&#xA;    return fa[v] = getfa(fa[v]);&#xA;}&#xA;&#xA;void init()&#xA;{&#xA;    memset(ok, 0, sizeof(ok));&#xA;    memset(sz, 0, sizeof(sz));&#xA;    cin &amp;gt;&amp;gt; n;&#xA;    string a;&#xA;    for ( int i(&#39;a&#39;); i &amp;lt;= &#39;z&#39;; i++) fa[i] = i;&#xA;    for ( int i(1); i &amp;lt;= n; i++)&#xA;    {&#xA;        cin &amp;gt;&amp;gt; a;&#xA;        int x = a[0], y = a[a.size() - 1];&#xA;        fa[getfa(x)] = getfa(y);&#xA;        ok[x] = ok[y] = true;&#xA;        sz[x]++;&#xA;        sz[y]--;&#xA;    }&#xA;}&#xA;&#xA;bool check()&#xA;{&#xA;    int tf = 0 , i;&#xA;    for ( i = &#39;a&#39;; i &amp;lt;= &#39;z&#39;; i++)&#xA;    {&#xA;        if (ok[i])&#xA;        {&#xA;            if ( !tf ) tf = getfa(i);&#xA;            else if ( getfa(i) != tf ) return false;        //  不连通&#xA;        }&#xA;    }&#xA;&#xA;    int c1 = 0, c2 = 0;&#xA;    for ( int i(&#39;a&#39;); i &amp;lt;= &#39;z&#39;; i++)&#xA;    {&#xA;        if (!ok[i]) continue;&#xA;        if ( sz[i] == 0 ) continue;&#xA;        else if ( sz[i] == 1 ) c1++;&#xA;        else if ( sz[i] == -1) c2++;&#xA;        else return false;              //  其它乱七八糟的情况 比如 ab ab out[a]=2 in[b]=2 &#xA;    }&#xA;&#xA;    if ( (c1 == 1 &amp;amp;&amp;amp; c2 == 1) || (c1 == 0 &amp;amp;&amp;amp; c2 == 0) ) //  单向路径 or 回路&#xA;        return true;&#xA;    else&#xA;        return false;&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin);&#xA;    for ( cin &amp;gt;&amp;gt; T; T--; )&#xA;    {&#xA;        init();&#xA;        if (check())&#xA;            cout &amp;lt;&amp;lt; &amp;quot;Ordering is possible.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;        else&#xA;            cout &amp;lt;&amp;lt; &amp;quot;The door cannot be opened.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;二分图最大匹配&#34; href=&#34;#二分图最大匹配&#34;&gt;&lt;/a&gt;二分图最大匹配&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;@ POJ 3041 Asteroids 匈牙利算法&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;看起来像个 DP 神马的。竟然是二分图匹配。。&#xA;看着啊，行与行之间相互独立，一个行可以就炸掉很多列。（列的道理一样），如果替换一些字。&#xA;       点与点之间相互独立，一个点就可以炸掉很多边。&#xA;so，可以把行列看成一个点，把一个炸弹看成一条边，然后题目就转换城了最小点击覆盖（即最大匹配）。&#xA;&#xA;这个题的思路就是上面说的，每一个炸弹（x，y）看做一条边，两个端点就是它的行列x 和 y。任意炸掉x y期中一个点都可以把可以把这条边炸掉。跟题目一样了。&#xA;就这么神奇。。&#xA;*/&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;const int N = 555;&#xA;int n, m, g[N][N], chk[N], match[N];&#xA;&#xA;int dfs(int v){&#xA;    int t;&#xA;    for ( int i = 1; i &amp;lt;= n; i++){&#xA;        if ( g[i][v] &amp;amp;&amp;amp; !chk[i] ){&#xA;            chk[i] = 1;&#xA;            t = match[i];&#xA;            match[i] = v;&#xA;            if ( t == -1 || dfs(t) ) return 1;&#xA;            match[i] = t;&#xA;        }&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;int main(){&#xA;    while ( ~scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n ,&amp;amp;m) ){&#xA;        memset(g, 0, sizeof(g));&#xA;        while ( m-- ){&#xA;            int a, b;&#xA;            scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);&#xA;            g[a][b] = 1;&#xA;        }&#xA;        int ans = 0;&#xA;        memset(match, 255, sizeof(match));&#xA;        for ( int i = 1; i &amp;lt;= n; i++){&#xA;            memset( chk, 0, sizeof(chk));&#xA;            ans += dfs(i);&#xA;        }&#xA;        printf(&amp;quot;%d\n&amp;quot;, ans);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
  </channel>
</rss>
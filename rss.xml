<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>zhr&#39;sTech</title>
    <link>http://dashayu.tk</link>
    <pubDate>12 Nov 14 20:07 CST</pubDate>
    <item>
      <title>acmtips</title>
      <link>http://dashayu.tk/default/acmtips/</link>
      <pubDate>2014-10-08 12:00:00 +0800</pubDate>
      <description>&lt;div&gt;&#xA;&#xA;    &lt;div id=&#39;Directory&#39;&gt;&lt;/div&gt;&#xA;    &lt;script&gt;&#xA;    &#xA;        var tt = [&#34;&#34;, &#34;一&#34;, &#34;二&#34;, &#34;三&#34;, &#34;四&#34;, &#34;五&#34;, &#34;六&#34;, &#34;七&#34;, &#34;八&#34;, &#34;九&#34;, &#34;十&#34;];&#xA;        var tq = [&#34;&#34;, &#34;①&#34;, &#34;②&#34;, &#34;③&#34;, &#34;④&#34;, &#34;⑤&#34;, &#34;⑥&#34;, &#34;⑦&#34;, &#34;⑧&#34;, &#34;⑨&#34;, &#34;⑩&#34;];&#xA;&#xA;        window.onload = function(){&#xA;            return;&#xA;            h1 = document.querySelectorAll(&#34;h1&#34;);           h2 = document.querySelectorAll(&#34;h2&#34;);           h3 = document.querySelectorAll(&#34;h3&#34;);           h4 = document.querySelectorAll(&#34;h4&#34;);&#xA;            &#xA;            var txt = &#34;&lt;h2&gt; Directory &lt;/h2&gt;&#34;;&#xA;            txt += &#34;&lt;pre&gt;&#34;&#xA;            for ( t1=0; t1&lt;h1.length; t1++ ){&#xA;                txt += &#34;&lt;h3&gt;&#34; + (tt[t1+1]) + &#34;.&#34; + h1[t1].innerHTML + &#34;&lt;/h3&gt;&#34;;&#xA;                for ( t2=0; t2&lt;h2.length; t2++ ) if (h2[t2].offsetTop &gt; h1[t1].offsetTop &amp;&amp; ( t1==h1.length-1 ||  h2[t2].offsetTop &lt; h1[t1+1].offsetTop )) {&#xA;                    txt += &#34;&lt;h4&gt;   &#34; + (t2+1) + &#34;. &#34; + h2[t2].innerHTML + &#34;&lt;/h4&gt;&#34;;&#xA;                    for (t3=0; t3&lt;h3.length; t3++ ) if (h3[t3].offsetTop &gt; h2[t2].offsetTop &amp;&amp; ( t2==h2.length-1 ||  h3[t3].offsetTop &lt; h2[t2+1].offsetTop )) {&#xA;                        txt += &#34;&lt;h5&gt;       &#34; + (t3+1) + &#34;) &#34; + h3[t3].innerHTML + &#34;&lt;/h5&gt;&#34;;&#xA;                        for ( t4=0; t4&lt;h4.length; t4++ ) if (h4[t4].offsetTop &gt; h3[t3].offsetTop &amp;&amp; ( t3==h3.length-1 ||  h4[t4].offsetTop &lt; h3[t3+1].offsetTop )) {&#xA;                            txt += &#34;         | &#34; + h4[t4].innerHTML + &#34;\n&#34;;&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;            txt += &#34;&lt;/pre&gt;&#34;;&#xA;            document.getElementById(&#34;Directory&#34;).innerHTML = txt;&#xA;        }&#xA;    &lt;/script&gt;&#xA;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;acm语法基础&#34; href=&#34;#acm语法基础&#34;&gt;&lt;/a&gt;ACM语法基础&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;c/cpp不常用的知识点&#34; href=&#34;#c/cpp不常用的知识点&#34;&gt;&lt;/a&gt;C/CPP不常用的知识点&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;字符串拆分&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;char ss[] = &amp;quot;(1,2,3,4)&amp;quot;;&#xA;char *p = strtok(ss, &amp;quot;(,)&amp;quot;);&#xA;for (int i(1); i&amp;lt;=n; i++) {&#xA;    sscanf(p, &amp;quot;%d&amp;quot;, &amp;amp;k);&#xA;    p = strtok(NULL, &amp;quot;,)&amp;quot;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;gets 、fgets 、getline&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gets 会过滤行首空格（不含&lt;code&gt;\n&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;li&gt;fgets 完全读入，把&lt;code&gt;\n&lt;/code&gt;吃进字符串末位，与scanf混用时容易出错&lt;/li&gt;&#xA;&lt;li&gt;getline 自动跳转下一行，不会过滤行首空格&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;java快速读写&#34; href=&#34;#java快速读写&#34;&gt;&lt;/a&gt;Java快速读写&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;例题&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;@ hdoj 5047 Sawtooth&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;读入一个大数，按照特定公式计算结果。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;import java.math.*;  &#xA;import java.util.*;  &#xA;import java.io.*;  &#xA;  &#xA;public class Main {  &#xA;    public static void main(String[] args) throws Exception {  &#xA;          &#xA;        BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));    &#xA;        BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out));  &#xA;          &#xA;        BigInteger n, ans, a1, a2, a7, a8;  &#xA;        a1 = BigInteger.valueOf(1);  &#xA;        a2 = BigInteger.valueOf(2);  &#xA;        a7 = BigInteger.valueOf(7);  &#xA;        a8 = BigInteger.valueOf(8);  &#xA;          &#xA;        String ss = cin.readLine();  &#xA;        int T = Integer.parseInt(ss);  &#xA;          &#xA;        for(int i=1; i&amp;lt;=T; i++){  &#xA;            ss = cin.readLine();  &#xA;            n = new BigInteger( ss );  &#xA;            cout.write( &amp;quot;Case #&amp;quot;+i+&amp;quot;: &amp;quot; );  &#xA;              &#xA;            ans = n.multiply(n).multiply(a8);  &#xA;            ans = ans.subtract(a7.multiply(n));  &#xA;            ans = ans.add(a1);  &#xA;              &#xA;            cout.write( ans.toString() );  &#xA;            cout.newLine();  &#xA;            cout.flush();  &#xA;        }  &#xA;  &#xA;    }  &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;模拟易错点&#34; href=&#34;#模拟易错点&#34;&gt;&lt;/a&gt;模拟易错点&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;a&#34; href=&#34;#a&#34;&gt;&lt;/a&gt;a&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;b&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;@ POJ 1017 Packets | 装完大包装小包&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;6种物品，体积分别为1*1 2*2 ... 6*6 。每种数量有20000&#xA;包裹体积为6*6，问装满所有的物品至少需要多少个包裹。&#xA;solution：&#xA;从大到小装，有缝隙了依次选小的。&#xA;*/&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;int n=6,t;&#xA;int a[8];&#xA;int push(int t,int i, int num){             // 把num个a[i]放进容量为t的箱子里，返回箱子容量&#xA;    if ( num &amp;gt; a[i]) num = a[i];&#xA;    t -= i*i * num;&#xA;    a[i] -= num;&#xA;    return t;&#xA;}&#xA;int main(){&#xA;    for(;;){&#xA;        int ts = 0;&#xA;        for ( int i(1);i&amp;lt;=n;i++){&#xA;            cin &amp;gt;&amp;gt; a[i];&#xA;            ts+=a[i];&#xA;        }&#xA;        if (!ts) break;&#xA;&#xA;        int s =a[6]+a[5]+a[4];&#xA;&#xA;        // a5&#xA;        if (a[5]*11 &amp;gt;= a[1]) a[1] = 0;&#xA;        else a[1] -= a[5]*11;&#xA;&#xA;        // a4&#xA;        for ( int i(1);i&amp;lt;=a[4];i++){&#xA;            t = push(20,2,5);&#xA;            if (t) t = push(t,1,t);&#xA;        }&#xA;&#xA;        // a3&#xA;        s += a[3] / 4;      // 整装3&#xA;        a[3] %= 4;&#xA;        if (a[3]){                                  //  剩下的空间分情况装2&#xA;            t = 36 - a[3]*9;&#xA;            if ( a[3] == 1 ) t = push(t,2,5);&#xA;            if ( a[3] == 2 ) t = push(t,2,3);&#xA;            if ( a[3] == 3 ) t = push(t,2,1);&#xA;            if (t) t = push(t,1,t);                     //  剩下的空间都装1&#xA;            s++;&#xA;        }&#xA;&#xA;        // a2&#xA;        s += a[2] / 9;&#xA;        a[2] %= 9;&#xA;        if (a[2]){&#xA;            t = 36 - a[2] * 4;&#xA;            t = push(t,1,t);&#xA;            s++;&#xA;        }&#xA;&#xA;        // a1&#xA;        s += a[1] / 36;&#xA;        a[1] %= 36;&#xA;        if (a[1]) s++;&#xA;&#xA;        cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;@ USACO 1.4.3 The Clocks&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;根据九个表和九个操作的关系，得出下列关系表：&#xA;先列一下钟表与矩阵的关系图：&#xA;Ci = C[i] / 3; &#xA;clocks  operates&#xA;1   1 2 4       ( C1 + p1 + p2 + p4 ) % 4 == 0&#xA;2   1 2 3 5     ( C2 + p1 + p2 + p3 + p5 ) % 4 == 0 &#xA;3   2 3 6       ...&#xA;4   1 4 5 7     ...&#xA;5   1 3 5 7 9   ...&#xA;6   3 5 6 9 &#xA;7   4 7 8&#xA;8   5 7 8 9&#xA;9   6 8 9&#xA;&#xA;把上面的关系式反过来，就能在已知 c[i] 通过枚举部分 pi 求出其它 pi &#xA;我枚举的是123三个操作，然后剩下6个操作就可以就确定了。&#xA;*/&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;using namespace std;&#xA;int c[11];&#xA;int cal(int a, int b, int c){&#xA;    int t =  - a - b - c;&#xA;    while ( t &amp;lt; 0 ) t += 4;&#xA;    return t;&#xA;}&#xA;int cal(int a, int b, int c, int d){&#xA;    int t =  - a - b - c - d;&#xA;    while ( t &amp;lt; 0 ) t += 4;&#xA;    return t;&#xA;}&#xA;int main(){&#xA;    freopen(&amp;quot;clocks.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);&#xA;    freopen(&amp;quot;clocks.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);&#xA;    for (int i(1);i&amp;lt;=9;i++) {&#xA;        cin &amp;gt;&amp;gt; c[i];&#xA;        c[i] /= 3;&#xA;    }&#xA;    int p[11];&#xA;    bool found = false;&#xA;    for ( p[1] = 0; p[1] &amp;lt; 4; p[1]++ ){&#xA;        for ( p[2] = 0; p[2] &amp;lt; 4; p[2]++ ){&#xA;            for ( p[3] = 0; p[3] &amp;lt; 4; p[3]++ ){&#xA;                p[4] = cal(c[1], p[1], p[2]);&#xA;                p[5] = cal(c[2], p[1], p[2], p[3]);&#xA;                p[6] = cal(c[3], p[2], p[3]);&#xA;                p[7] = cal(c[4], p[1], p[4], p[5]);&#xA;                p[8] = cal(c[7], p[4], p[7]);&#xA;                p[9] = cal(c[9], p[6], p[8]);&#xA;                if (((c[5] + p[1] + p[3] + p[5] + p[7] + p[9]) % 4 == 0) &amp;amp;&amp;amp;&#xA;                    ((c[8] + p[5] + p[7] + p[8] + p[9] ) % 4 == 0) &amp;amp;&amp;amp;&#xA;                    ((c[6] + p[3] + p[5] + p[6] + p[9] ) % 4 == 0 )){&#xA;                    found = 1;&#xA;                    break;&#xA;                }&#xA;                if ( found ) break;&#xA;            }&#xA;            if ( found ) break;&#xA;        }&#xA;        if ( found ) break;&#xA;    }&#xA;    int i = 1;&#xA;    while ( p[i] == 0 ) i++;&#xA;    printf(&amp;quot;%d&amp;quot;,i);&#xA;    p[i--]--;&#xA;    while ( ++i &amp;lt;= 9 ) while ( p[i]-- ) printf(&amp;quot; %d&amp;quot;,i);&#xA;    printf(&amp;quot;\n&amp;quot;);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;搜索&#34; href=&#34;#搜索&#34;&gt;&lt;/a&gt;搜索&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;多状态标记&#34; href=&#34;#多状态标记&#34;&gt;&lt;/a&gt;多状态标记&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;@ HDU 5024 Wang Xifeng&amp;rsquo;s Little Plot 广州区域赛&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;题意：找到一个最长的L型&#xA;思路：把L拆成两个直线，枚举所有的情况，记忆化搜索&#xA;*/&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#include &amp;lt;algorithm&amp;gt;&#xA;using namespace std;&#xA;const int maxn = 110;&#xA;&#xA;int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};&#xA;int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};&#xA;int n, f[maxn][maxn][8];&#xA;char g[maxn][maxn];&#xA;&#xA;int dfs(int x, int y, int dir) {&#xA;    if (f[x][y][dir] != -1)&#xA;        return f[x][y][dir];&#xA;&#xA;    if (g[x+dx[dir]][y+dy[dir]] == &#39;.&#39;)&#xA;        return f[x][y][dir] = 1 + dfs(x+dx[dir], y+dy[dir], dir);&#xA;    else return f[x][y][dir] = 1;&#xA;}&#xA;&#xA;int main() {&#xA;    while (scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) != EOF &amp;amp;&amp;amp; n) {&#xA;        memset(f, -1, sizeof(f));&#xA;        memset(g, 0, sizeof(g));&#xA;        for (int i = 1; i &amp;lt;= n; i++)&#xA;            scanf(&amp;quot;%s&amp;quot;, g[i]+1);&#xA;&#xA;        int ans = -1;&#xA;        for (int i = 1; i &amp;lt;= n; i++)&#xA;            for (int j = 1; j &amp;lt;= n; j++) &#xA;                if (g[i][j] == &#39;.&#39;) {&#xA;                    ans = max(ans, dfs(i, j, 0) + dfs(i, j, 2) - 1);&#xA;                    ans = max(ans, dfs(i, j, 1) + dfs(i, j, 2) - 1);&#xA;                    ans = max(ans, dfs(i, j, 1) + dfs(i, j, 3) - 1);&#xA;                    ans = max(ans, dfs(i, j, 0) + dfs(i, j, 3) - 1);&#xA;                    ans = max(ans, dfs(i, j, 4) + dfs(i, j, 5) - 1);&#xA;                    ans = max(ans, dfs(i, j, 4) + dfs(i, j, 6) - 1);&#xA;                    ans = max(ans, dfs(i, j, 7) + dfs(i, j, 5) - 1);&#xA;                    ans = max(ans, dfs(i, j, 7) + dfs(i, j, 6) - 1);&#xA;                }&#xA;        printf(&amp;quot;%d\n&amp;quot;, ans);&#xA;    }   &#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;@ HDU 5025 Saving Tang Monk&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;题意：给一个地图，孙悟空(K)救唐僧(T)，地图中&amp;rsquo;S&amp;rsquo;表示蛇，第一次到这要杀死蛇（蛇最多5条），多花费一分钟，&amp;rsquo;1&amp;rsquo;~&amp;rsquo;m&amp;rsquo;表示m个钥匙(m&amp;lt;=9)，孙悟空要依次拿到这m个钥匙，然后才能去救唐僧，集齐m个钥匙之前可以经过唐僧，集齐x个钥匙以前可以经过x+1,x+2..个钥匙，问最少多少步救到唐僧。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;本题主要是每一条蛇状态的记录，使用状态压缩，将每一条蛇的状态用二进制位记录下来，1代表活，0代表死。&#xA;使用vis四维数组记录每一点走过的状态，x,y分别表示位置，k 钥匙，s 表示蛇的状态，b 表示步数。&#xA;*/&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;algorithm&amp;gt;&#xA;#include &amp;lt;cmath&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#include &amp;lt;queue&amp;gt;&#xA;#include &amp;lt;stack&amp;gt;&#xA;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;set&amp;gt;&#xA;#include &amp;lt;map&amp;gt;&#xA;const int inf=0xfffffff;&#xA;typedef long long ll;&#xA;using namespace std;&#xA;&#xA;char m[105][105];&#xA;int vis[105][105][15][40];&#xA;int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};&#xA;int sx, sy, sn, N, M;&#xA;struct node&#xA;{&#xA;    int x, y, k, s, b;&#xA;};&#xA;queue&amp;lt;node&amp;gt; q;&#xA;int ans;&#xA;&#xA;void bfs()&#xA;{&#xA;    node now;&#xA;    q.push((node){sx, sy, 0, 0, 0});&#xA;    while(!q.empty()){&#xA;        now = q.front();&#xA;        q.pop();&#xA;        int x = now.x, y = now.y, k = now.k, s = now.s, b = now.b;&#xA;        if(k == M &amp;amp;&amp;amp; m[x][y] == &#39;T&#39;){&#xA;            ans = min(ans, b);&#xA;        }&#xA;&#xA;        if(vis[x][y][k][s] != 0) continue;&#xA;        vis[x][y][k][s] = 1;&#xA;&#xA;        for(int i = 0; i &amp;lt; 4; i ++){&#xA;            int nx = x + dx[i], ny = y + dy[i];&#xA;            int snn = m[nx][ny] - &#39;A&#39;;&#xA;&#xA;            if(snn &amp;gt;= 0 &amp;amp;&amp;amp; snn &amp;lt; sn){&#xA;                if((1&amp;lt;&amp;lt;snn) &amp;amp; s) q.push((node) {nx, ny, k, s, b + 1});&#xA;                else q.push((node) {nx, ny, k,  (1&amp;lt;&amp;lt;snn) | s, b + 2});&#xA;            }&#xA;            else{&#xA;                if(m[nx][ny] == k + &#39;1&#39;){&#xA;                    q.push((node) {nx, ny, k + 1, s, b + 1});&#xA;                }&#xA;                else if(nx &amp;gt; 0 &amp;amp;&amp;amp; nx &amp;lt;= N &amp;amp;&amp;amp; ny &amp;gt; 0 &amp;amp;&amp;amp; ny &amp;lt;= N &amp;amp;&amp;amp; m[nx][ny] != &#39;#&#39;)&#xA;                    q.push((node) {nx, ny, k, s, b + 1});&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;int main()&#xA;{&#xA;    //freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin);&#xA;    while(~scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;N, &amp;amp;M)){&#xA;        if(N == 0 &amp;amp;&amp;amp; M == 0) break;&#xA;        memset(m, 0, sizeof(m));&#xA;        memset(vis, 0, sizeof(vis));&#xA;        sn = 0;&#xA;        for(int i = 1; i &amp;lt;= N; i ++){&#xA;            scanf(&amp;quot;%s&amp;quot;, m[i] + 1);&#xA;            for(int j = 1; j &amp;lt;= N; j ++){&#xA;                if(m[i][j] == &#39;K&#39;){&#xA;                    sx = i;&#xA;                    sy = j;&#xA;                }&#xA;                if(m[i][j] == &#39;S&#39;){&#xA;                    m[i][j] = &#39;A&#39; + sn;&#xA;                    sn ++;&#xA;                }&#xA;            }&#xA;        }&#xA;        ans = inf;&#xA;        bfs();&#xA;        if(ans == inf) printf(&amp;quot;impossible\n&amp;quot;);&#xA;        else printf(&amp;quot;%d\n&amp;quot;, ans);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;解法：BFS，每个节点维护四个值：&#xA;x,y ： 当前坐标&#xA;key ：已经集齐了key个钥匙&#xA;step：已经走了多少步&#xA;S ：   蛇的访问状态 (2^5的数表示，某位为1表示已经杀过了)&#xA;然后把唐僧看做钥匙m+1，再加点优化：&#xA;为了避免超时，用一个全局的dis[x][y][key][S] 表示到(x,y),已经集齐到key个钥匙，蛇的访问状态为S时的最小步数，如果BFS扩展的时候，当前状态的步数&amp;gt;=dis[当前状态]，那么就不再扩展下去了。&#xA;BFS中的逻辑就很简单了，看代码吧。&#xA;最后，枚举蛇的状态S，取dis[x][y][m+1][S]的最小值即为最小步数。&#xA;*/&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;#include &amp;lt;cmath&amp;gt;&#xA;#include &amp;lt;algorithm&amp;gt;&#xA;#include &amp;lt;queue&amp;gt;&#xA;#include &amp;lt;map&amp;gt;&#xA;#define INF 0x3f3f3f3f&#xA;using namespace std;&#xA;#define N 1000007&#xA;&#xA;int dis[104][104][12][33],Stot,M;&#xA;struct node&#xA;{&#xA;    int x,y,key,step,S;&#xA;};&#xA;int dx[4] = {0,0,1,-1};&#xA;int dy[4] = {1,-1,0,0};&#xA;map&amp;lt;pair&amp;lt;int,int&amp;gt;,int&amp;gt; snake;&#xA;char ss[105][105];&#xA;int n,m;&#xA;&#xA;bool OK(int nx,int ny)&#xA;{&#xA;    if(nx &amp;lt; n &amp;amp;&amp;amp; nx &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; n &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; ss[nx][ny] != &#39;#&#39;)&#xA;        return true;&#xA;    return false;&#xA;}&#xA;&#xA;void bfs(node s)&#xA;{&#xA;    queue&amp;lt;node&amp;gt; que;&#xA;    que.push(s);&#xA;    while(!que.empty())&#xA;    {&#xA;        node now = que.front();&#xA;        que.pop();&#xA;        int nx = now.x, ny = now.y;&#xA;        int key = now.key, step = now.step;&#xA;        int S = now.S;&#xA;        node tmp;&#xA;        for(int k=0;k&amp;lt;4;k++)&#xA;        {&#xA;            int kx = nx + dx[k];&#xA;            int ky = ny + dy[k];&#xA;            if(!OK(kx,ky)) continue;&#xA;            tmp.x = kx,tmp.y = ky;&#xA;            if(ss[kx][ky] == &#39;S&#39;)                    //蛇&#xA;            {&#xA;                int ind = snake[make_pair(kx,ky)];   //是第几条蛇&#xA;                tmp.key = key;&#xA;                if(S &amp;amp; (1&amp;lt;&amp;lt;(ind-1)))                 //如果已经杀死&#xA;                {&#xA;                    tmp.S = S;&#xA;                    tmp.step = step+1;&#xA;                } &#xA;                else                                 //否则要杀&#xA;                {&#xA;                    tmp.S = S|(1&amp;lt;&amp;lt;(ind-1));&#xA;                    tmp.step = step+2;&#xA;                }&#xA;                if(tmp.step &amp;lt; dis[kx][ky][tmp.key][tmp.S])&#xA;                {&#xA;                    dis[kx][ky][tmp.key][tmp.S] = tmp.step;&#xA;                    que.push(tmp);&#xA;                }&#xA;            }&#xA;            else if(ss[kx][ky] &amp;gt;= &#39;1&#39; &amp;amp;&amp;amp; ss[kx][ky] &amp;lt;= &#39;9&#39;)  //钥匙点&#xA;            {&#xA;                int num = ss[kx][ky] - &#39;0&#39;;&#xA;                tmp.step = step+1;&#xA;                tmp.S = S;&#xA;                if(num == key+1)                             //正好是要拿的那个&#xA;                    tmp.key = key+1;&#xA;                else&#xA;                    tmp.key = key;&#xA;                if(tmp.step &amp;lt; dis[kx][ky][tmp.key][tmp.S])&#xA;                {&#xA;                    dis[kx][ky][tmp.key][tmp.S] = tmp.step;&#xA;                    que.push(tmp);&#xA;                }&#xA;            }&#xA;            else if(ss[kx][ky] == &#39;$&#39;)   //唐僧这个点&#xA;            {&#xA;                tmp.key = key;&#xA;                tmp.S = S;&#xA;                tmp.step = step+1;&#xA;                if(M == key+1)           //已经集齐了所有钥匙，不再扩展，更新dis即可&#xA;                    dis[kx][ky][M][S] = min(dis[kx][ky][M][S],step+1);&#xA;                else                     //没有集齐，继续走&#xA;                    que.push(tmp);&#xA;            }&#xA;            else if(ss[kx][ky] == &#39;.&#39;)&#xA;            {&#xA;                tmp.key = key;&#xA;                tmp.S = S;&#xA;                tmp.step = step+1;&#xA;                if(tmp.step &amp;lt; dis[kx][ky][tmp.key][tmp.S])&#xA;                {&#xA;                    dis[kx][ky][tmp.key][tmp.S] = tmp.step;&#xA;                    que.push(tmp);&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    int Sx,Ex,Sy,Ey;&#xA;    int i,j;&#xA;    while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)!=EOF &amp;amp;&amp;amp; n+m)&#xA;    {&#xA;        if(n == 1)&#xA;        {&#xA;            puts(&amp;quot;impossible&amp;quot;);&#xA;            continue;&#xA;        }&#xA;        snake.clear();&#xA;        Stot = 0;&#xA;        M = m+1;&#xA;        for(i=0;i&amp;lt;n;i++)&#xA;        {&#xA;            scanf(&amp;quot;%s&amp;quot;,ss[i]);&#xA;            for(j=0;j&amp;lt;n;j++)&#xA;            {&#xA;                if(ss[i][j] == &#39;K&#39;)&#xA;                    Sx = i,Sy = j, ss[i][j] = &#39;.&#39;;&#xA;                else if(ss[i][j] == &#39;T&#39;)&#xA;                    Ex = i,Ey = j, ss[i][j] = &#39;$&#39;;&#xA;                else if(ss[i][j] == &#39;S&#39;)&#xA;                    snake[make_pair(i,j)] = ++Stot;&#xA;            }&#xA;        }&#xA;        node tmp;&#xA;        tmp.x = Sx,tmp.y = Sy,tmp.key = 0,tmp.step = 0,tmp.S = 0;&#xA;        memset(dis,INF,sizeof(dis));&#xA;        dis[Sx][Sy][0][0] = 0;&#xA;        bfs(tmp);&#xA;        int mini = INF;&#xA;        for(i=0;i&amp;lt;(1&amp;lt;&amp;lt;Stot);i++)&#xA;            mini = min(mini,dis[Ex][Ey][M][i]);&#xA;        if(mini == INF)&#xA;            puts(&amp;quot;impossible&amp;quot;);&#xA;        else&#xA;            printf(&amp;quot;%d\n&amp;quot;,mini);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;图论&#34; href=&#34;#图论&#34;&gt;&lt;/a&gt;图论&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;欧拉回路-哈密顿回路&#34; href=&#34;#欧拉回路-哈密顿回路&#34;&gt;&lt;/a&gt;欧拉回路 哈密顿回路&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;判断存在&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;判断欧拉通路：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个有向图存在欧拉回路必定也存在欧拉通路&amp;hellip;因为通路的定义包括了回路&lt;/li&gt;&#xA;&lt;li&gt;不考虑为欧拉回路的情况..一个有向图是欧拉通路就必须有一个点出度-入度=1,一个点入度-出度=1..这两点就是欧拉通路的起点和终点..并且该图连通&lt;/li&gt;&#xA;&lt;li&gt;我自己加一条，其实是对2的理解：入读-出度&amp;gt;1 时直接return false ，排除 a-&amp;gt;b a-&amp;gt;c 这种情况&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;判断欧拉回路：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;无向图是欧拉图的充要条件是所有点的度为偶数并且所有点联通&lt;br /&gt;&#xA;有向图是欧拉图的充要条件是所有点的入度=出度..并且联通&amp;hellip;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;判断连通:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;dfs遍历，这里有一份参考代码不过我一直怀疑其正确性。因为你无法确定有向图的起点，比如 a-&amp;gt;b-&amp;gt;c 如果你从b点开始搜的话就会悲催，但是你不知道b点上面还有没有点。&lt;/li&gt;&#xA;&lt;li&gt;并查集，并查集的方便之处不用废话。但是在图论中两点之间有多条边时需要注意一些细节的处理。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;关于判断入读出度:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一种办法是分别记录 in[] out[]&#xA;我用的办法是一个数组：sz[x]++ 表示拉出一条边，sz[x]&amp;ndash;表示走来一条边，sz[x]==1 sz[x]==-1 就是上面的两种情况&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h4&gt;@ UVa 10129 Play on Words&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;题意就是给你一堆单词，按首位顺序排列起来，问你有没有解。&#xA;第一眼看上去是个哈密顿通路，单词当做节点，首尾关系作边，听上去妥妥的不过N有100000 复杂度太恐怖。&#xA;其实是从刘汝佳的小白书第二版（其实该叫小紫红书了）上欧拉回路那节看到的，所以得考虑考虑转换&#xA;把单词当边，首尾字符当做点 题目就转变为 欧拉通路&#xA;*/&#xA;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;#define N 101010&#xA;using namespace std;&#xA;&#xA;int sz[333];&#xA;int fa[333];&#xA;bool ok[333];   //  数据中使用到的单词&#xA;int n, T;&#xA;&#xA;int getfa(int v)&#xA;{&#xA;    if ( fa[v] == v ) return v;&#xA;    return fa[v] = getfa(fa[v]);&#xA;}&#xA;&#xA;void init()&#xA;{&#xA;    memset(ok, 0, sizeof(ok));&#xA;    memset(sz, 0, sizeof(sz));&#xA;    cin &amp;gt;&amp;gt; n;&#xA;    string a;&#xA;    for ( int i(&#39;a&#39;); i &amp;lt;= &#39;z&#39;; i++) fa[i] = i;&#xA;    for ( int i(1); i &amp;lt;= n; i++)&#xA;    {&#xA;        cin &amp;gt;&amp;gt; a;&#xA;        int x = a[0], y = a[a.size() - 1];&#xA;        fa[getfa(x)] = getfa(y);&#xA;        ok[x] = ok[y] = true;&#xA;        sz[x]++;&#xA;        sz[y]--;&#xA;    }&#xA;}&#xA;&#xA;bool check()&#xA;{&#xA;    int tf = 0 , i;&#xA;    for ( i = &#39;a&#39;; i &amp;lt;= &#39;z&#39;; i++)&#xA;    {&#xA;        if (ok[i])&#xA;        {&#xA;            if ( !tf ) tf = getfa(i);&#xA;            else if ( getfa(i) != tf ) return false;        //  不连通&#xA;        }&#xA;    }&#xA;&#xA;    int c1 = 0, c2 = 0;&#xA;    for ( int i(&#39;a&#39;); i &amp;lt;= &#39;z&#39;; i++)&#xA;    {&#xA;        if (!ok[i]) continue;&#xA;        if ( sz[i] == 0 ) continue;&#xA;        else if ( sz[i] == 1 ) c1++;&#xA;        else if ( sz[i] == -1) c2++;&#xA;        else return false;              //  其它乱七八糟的情况 比如 ab ab out[a]=2 in[b]=2 &#xA;    }&#xA;&#xA;    if ( (c1 == 1 &amp;amp;&amp;amp; c2 == 1) || (c1 == 0 &amp;amp;&amp;amp; c2 == 0) ) //  单向路径 or 回路&#xA;        return true;&#xA;    else&#xA;        return false;&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin);&#xA;    for ( cin &amp;gt;&amp;gt; T; T--; )&#xA;    {&#xA;        init();&#xA;        if (check())&#xA;            cout &amp;lt;&amp;lt; &amp;quot;Ordering is possible.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;        else&#xA;            cout &amp;lt;&amp;lt; &amp;quot;The door cannot be opened.&amp;quot; &amp;lt;&amp;lt; endl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;二分图最大匹配&#34; href=&#34;#二分图最大匹配&#34;&gt;&lt;/a&gt;二分图最大匹配&lt;/h2&gt;&#xA;&#xA;&lt;h4&gt;@ POJ 3041 Asteroids 匈牙利算法&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;cpp&#34;&gt;/*&#xA;看起来像个 DP 神马的。竟然是二分图匹配。。&#xA;看着啊，行与行之间相互独立，一个行可以就炸掉很多列。（列的道理一样），如果替换一些字。&#xA;       点与点之间相互独立，一个点就可以炸掉很多边。&#xA;so，可以把行列看成一个点，把一个炸弹看成一条边，然后题目就转换城了最小点击覆盖（即最大匹配）。&#xA;&#xA;这个题的思路就是上面说的，每一个炸弹（x，y）看做一条边，两个端点就是它的行列x 和 y。任意炸掉x y期中一个点都可以把可以把这条边炸掉。跟题目一样了。&#xA;就这么神奇。。&#xA;*/&#xA;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;const int N = 555;&#xA;int n, m, g[N][N], chk[N], match[N];&#xA;&#xA;int dfs(int v){&#xA;    int t;&#xA;    for ( int i = 1; i &amp;lt;= n; i++){&#xA;        if ( g[i][v] &amp;amp;&amp;amp; !chk[i] ){&#xA;            chk[i] = 1;&#xA;            t = match[i];&#xA;            match[i] = v;&#xA;            if ( t == -1 || dfs(t) ) return 1;&#xA;            match[i] = t;&#xA;        }&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;int main(){&#xA;    while ( ~scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n ,&amp;amp;m) ){&#xA;        memset(g, 0, sizeof(g));&#xA;        while ( m-- ){&#xA;            int a, b;&#xA;            scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);&#xA;            g[a][b] = 1;&#xA;        }&#xA;        int ans = 0;&#xA;        memset(match, 255, sizeof(match));&#xA;        for ( int i = 1; i &amp;lt;= n; i++){&#xA;            memset( chk, 0, sizeof(chk));&#xA;            ans += dfs(i);&#xA;        }&#xA;        printf(&amp;quot;%d\n&amp;quot;, ans);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>cs203的那点事儿</title>
      <link>http://dashayu.tk/Boring Notes/cs203%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</link>
      <pubDate>2014-07-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这篇文章有三个标签&lt;code&gt;LXMP&lt;/code&gt; &lt;code&gt;Go&lt;/code&gt; &lt;code&gt;HUSTOJ&lt;/code&gt;，在我接管服务器以前，这三个东西我是一个也不知道的，靠着自己的不懈折腾，时隔大半年，收获颇丰。今夜不眠，拿出来聊聊。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;lamp&#34; href=&#34;#lamp&#34;&gt;&lt;/a&gt;LAMP&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这是&lt;code&gt;HUSTOJ&lt;/code&gt;的原始架构，我接管服务器的第一件事就是一周内搭好&lt;code&gt;oj&lt;/code&gt;，那一周我是在机房没日没夜的呆了几天，终于把我们自己的&lt;code&gt;oj&lt;/code&gt;给架起来了。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Linux&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果真的要找基础，就是大一下蹭在&lt;code&gt;KDE&lt;/code&gt;下生活过三个月，后来移居&lt;code&gt;OSX&lt;/code&gt;但是敲命令的习惯还是保留了下来。以至于至今没怎么好好的用过&lt;code&gt;Windows&lt;/code&gt;！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在最开始，很多人给我的建议就是&lt;code&gt;鸟哥的私房菜&lt;/code&gt;，天哪这么厚一本书我怎么可能几天内看完！所以在最开始的时候其实很简单，需要什么了就去百度就去&lt;code&gt;Google&lt;/code&gt;，查不到的就去问各路大神了。由于迁居&lt;code&gt;OSX&lt;/code&gt;导致一直没有踏踏实实地下来学习过&lt;code&gt;Linux&lt;/code&gt;，导致今日依旧小白一个。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Apache&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;最早接触这些东西是当年看哈佛的计算机公开课时提到的&lt;code&gt;XAMPP&lt;/code&gt;，然后一直用了它很久包括使用&lt;code&gt;Linux&lt;/code&gt;时在本地学HTML5依旧用得它。所以在这个时候格外吃力，都是去百度&lt;code&gt;Apache如何修改网站位置&lt;/code&gt; &lt;code&gt;Apache如何添加子域名&lt;/code&gt;之类白痴之极的问题，也曾立志去研习&lt;code&gt;Apache&lt;/code&gt;配置详解，后来由于你们猜得到的原因就没怎么碰过了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在&lt;code&gt;Linux&lt;/code&gt;下最喜欢的命令就是&lt;code&gt;apt-get&lt;/code&gt;，特别喜欢&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;upgrade&lt;/code&gt;的感觉。我曾两次&lt;code&gt;upgrade&lt;/code&gt;服务器，第一次出现了小问题一个下午搞定了，第二次依旧手贱，结果把&lt;code&gt;HUSTOJ&lt;/code&gt;的&lt;code&gt;Judged&lt;/code&gt;搞坏了，边被吐槽边修复了两三天（当时正值计算机学院在&lt;code&gt;OJ&lt;/code&gt;上做算法作业！）深感无力回天，不得已拿&lt;code&gt;Go&lt;/code&gt;重写了&lt;code&gt;Judged&lt;/code&gt;。由于积累了数天的重判任务于是就把判题端开到了十进程。。两三天的调试，至今运行良好。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;MySQL&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;其实对MySQL的熟悉完全是嘴表层最表层的，没有系统学过数据库理论，甚至连&lt;code&gt;SQL&lt;/code&gt;语法都没怎么学过，同样是遇到一个问题就去白痴地问一次。开发&lt;code&gt;oj&lt;/code&gt;时几乎也都是&lt;code&gt;copy&lt;/code&gt;-&lt;code&gt;paste&lt;/code&gt;照猫画虎过来的。后来学&lt;code&gt;Go&lt;/code&gt;时认识了&lt;code&gt;orm&lt;/code&gt;这类东西，从此对&lt;code&gt;SQL&lt;/code&gt;再没有去看了。早上看到一篇程序员等级，最低级的被成为&lt;code&gt;CRUD&lt;/code&gt;程序员，我估计我连这些都不算够格。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;PHP&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;PHP&lt;/code&gt;在这些东西是最早接触的，曾在&lt;code&gt;w3school&lt;/code&gt;上看过，但是由于上述知识的匮乏，其实跟没学一样（曾一度去琢磨php和js该学哪个），&lt;/p&gt;&#xA;&#xA;&lt;p&gt;开发&lt;code&gt;oj&lt;/code&gt;时真正要用&lt;code&gt;php&lt;/code&gt;了那个时候一般我改一句代码&lt;code&gt;oj&lt;/code&gt;就会挂一次，经常被问得就是&lt;code&gt;今天&lt;/code&gt;oj&lt;code&gt;我怎么上着上着就上不去了过一会又好了！？&lt;/code&gt; &lt;code&gt;你是在作死！！！&lt;/code&gt;等等之类的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;庆幸毕竟是有压力在身上，学对&lt;code&gt;PHP&lt;/code&gt;还是学了点。也认识了很多，从语法灵活度来说PHP是多么简单的语言，但是在语法组织上你会觉得这是让人烦到死的东西。由于是&lt;code&gt;Python&lt;/code&gt; &lt;code&gt;Ruby&lt;/code&gt; &lt;code&gt;Go&lt;/code&gt; 等极简语法语言的崛起。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;go&#34; href=&#34;#go&#34;&gt;&lt;/a&gt;Go&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我为什么会走上&lt;code&gt;Go&lt;/code&gt;说来完全是打发寂寞，于是我就去网上看世界上有哪些语言，先被&lt;code&gt;python&lt;/code&gt; &lt;code&gt;ruby&lt;/code&gt; 这类轻巧的语言所吸引，又因为速度的传言转到了&lt;code&gt;NodeJS&lt;/code&gt;，暑假期间蹭用&lt;code&gt;HTML5&lt;/code&gt;写过一个游戏，我感觉到了&lt;code&gt;JS&lt;/code&gt;在某些方面的力不从心（当然一定是有解的只是感觉不那么优雅）。后来意外看到了&lt;code&gt;Go&lt;/code&gt;语言并被它深深地吸引。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;意外的是我的两个朋友哈工大的光光和电子科大的42大神都开始学&lt;code&gt;Go&lt;/code&gt;。回过头看那个时候正是一些东西在国内迅猛发展的时期，&lt;code&gt;Astaxie&lt;/code&gt;、&lt;code&gt;UnKnwon&lt;/code&gt;等大神开始大力推广&lt;code&gt;Go&lt;/code&gt;，&lt;code&gt;MongoDB&lt;/code&gt;当时还算最火的，当时&lt;code&gt;SSDB&lt;/code&gt;貌似还没出来的说。当时我周围的学长们大多都不知道这是些什么玩意。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在那个时候几列火车从我身边高速驶过，我不知道我是否属于这些列车，但是我知道，这些列车都将开往未来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;nginx&#34; href=&#34;#nginx&#34;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;由于某些历史原因使得我成了在很多方面有强迫症的人，很多方面都试图用最好的且不惜成本，浏览器、编辑器、播放器甚至输入法、日历等几乎所有类型的工具我都要做个横向对比找出最顺手的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;服务器软件也不例外，不知道被谁忽悠了&lt;code&gt;Nginx&lt;/code&gt;远远优于&lt;code&gt;Apache&lt;/code&gt;。下定决心要进入&lt;code&gt;Nginx&lt;/code&gt;的世界，从&lt;code&gt;LNMP&lt;/code&gt;的搭建、配置这些基本的学起，到后来需要高级功能时已不再使用&lt;code&gt;Apache&lt;/code&gt;，后来学了&lt;code&gt;Go&lt;/code&gt;，对&lt;code&gt;pass&lt;/code&gt; &lt;code&gt;rewrite&lt;/code&gt;要求多了就再没离开过&lt;code&gt;Nginx&lt;/code&gt;了。但是说时候这个环境比&lt;code&gt;LAMP&lt;/code&gt;复杂多了大概最开始的几次每次都出小问题，多配几次才可以顺利地搞下来。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;hustoj&#34; href=&#34;#hustoj&#34;&gt;&lt;/a&gt;HUSTOJ&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;HUSTOJ&lt;/code&gt;的代码写得极其简单随意，像我这种没有软件工程基础的人大概花了不到一天的功夫就搞懂了它的大概框架，改起来自然也是得心应手，越来后来一些问题也越来越明显：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;代码清晰度有待提高，大框架简单，细节上自然要复杂多了。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在做二次开发时每次的思路的很简单，但工作量甚大，譬如&lt;code&gt;user&lt;/code&gt;改一个字段，你就得把所有&lt;code&gt;select&lt;/code&gt;了&lt;code&gt;user&lt;/code&gt;的页面代码全部修改，还得边改边调试。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;从这几方面来讲随着需求越来越高，一直二次开发下去是个很不明智的做法，所以有必要规划一套适合各种复杂情况的在线编程学习平台。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;庆幸我正好在学&lt;code&gt;Go&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果把&lt;code&gt;HUSTOJ&lt;/code&gt;分为三块，&lt;code&gt;Web&lt;/code&gt; &lt;code&gt;Judged&lt;/code&gt; &lt;code&gt;Judge_client&lt;/code&gt;。前两部分基本已经用&lt;code&gt;Go&lt;/code&gt;重写。其中&lt;code&gt;Judged&lt;/code&gt;已经在服务器上正常使用半年，目前运行良好。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;最后&#34; href=&#34;#最后&#34;&gt;&lt;/a&gt;最后&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;之前在做&lt;code&gt;OJ&lt;/code&gt;的时候我就考虑一个问题，如果要比做&lt;code&gt;OJ&lt;/code&gt;，那我永远做不过杭电，结合自己的教育梦，我希望能一步一步打造一个在线编程教育平台。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>mactips</title>
      <link>http://dashayu.tk/default/mactips/</link>
      <pubDate>2014-07-01 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;网络服务&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;查看端口占用&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>hello, gor</title>
      <link>http://dashayu.tk/Boring Notes/hello%2C-gor/</link>
      <pubDate>2014-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;既然来了，就说说为什么来吧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;今天是个比较兴奋地日子，因为我的新显示器（&lt;a href=&#34;http://item.jd.com/933422.html&#34;&gt;AOC LV242WEM&lt;/a&gt;）终于到了，一下子就喜欢上了新屏幕，敞亮、饱和、逼真、鲜艳，反正就是棒极了！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;稀里糊涂就想试试拿 gor 在 github.io 上搭个博客了，说实话阿里的服务器即将到期没有资本也木有必要去续费。github.io 却看起来可以永存。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;使用几分钟后&#34; href=&#34;#使用几分钟后&#34;&gt;&lt;/a&gt;使用几分钟后&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;从 gor 的使用到github.io，到各种配置，官网都有很详细的说明我就不再赘述了。也可以看我的&lt;a href=&#34;2013/new-born.html&#34;&gt;第一篇&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;DISQUS广告&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;拿到这个博客你首先得干的第一件事应该就是去除评论框该死的广告！在&lt;code&gt;widgets/comments/config.yml&lt;/code&gt;里，把&lt;code&gt;short_name&lt;/code&gt;改成你自己的，如果没有怎么办？可以选择去建一个（也可以有一个快速去广告的办法就是乱加几个字母，这样首先就没有广告了），建的时候有一大堆对勾要选注意其中有一个&lt;code&gt;发现&lt;/code&gt;，果断去掉。然后更新&lt;code&gt;short_name&lt;/code&gt;就ok了&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;换成多说评论框&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;多说是在国内用的还算比较多的一个，所以把disqus替换成多说也是个很好的想法，置于怎么替换，下次再说。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;题外话&#34; href=&#34;#题外话&#34;&gt;&lt;/a&gt;题外话&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;MacDown&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这是一个看起来特别棒的markdown编辑器，堪比&lt;code&gt;CMD Markdown&lt;/code&gt;但是看起来不是偏离Markdown那么离谱。但是只支持Mac平台。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好了该说说这个博客要干嘛了。由于在github上，所以考虑还是技术为主吧。如果搞得还行，把抽风系列挂过来也不错~&lt;/p&gt;&#xA;&#xA;&lt;p&gt;就这样了，还得睡觉。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>About Me</title>
      <link>http://dashayu.tk/default/About-Me/</link>
      <pubDate>2014-06-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;爱生活，爱思考&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;兴趣爱好&#34; href=&#34;#兴趣爱好&#34;&gt;&lt;/a&gt;兴趣爱好&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编程技术&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序设计&lt;/li&gt;&#xA;&lt;li&gt;服务端开发&lt;/li&gt;&#xA;&lt;li&gt;前段折腾&lt;/li&gt;&#xA;&lt;li&gt;嵌入式探索&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;社交网络&#34; href=&#34;#社交网络&#34;&gt;&lt;/a&gt;社交网络&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://weibo.com/u/2409424241&#34;&gt;Weibo&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/nian.lao&#34;&gt;Facebook&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/micln&#34;&gt;Github&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://coding.net/u/kzzhr&#34;&gt;Coding.net&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;同学&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://pokerg.github.io/&#34;&gt;光光&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://asenrzhang.tk&#34;&gt;AsenR&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://blog.shizhisha.pw/&#34;&gt;时之沙砾&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://42.cnssuestc.org/&#34;&gt;42&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;关注的大牛们&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://wuwen.org/&#34;&gt;Unknwon&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://bluek404.net/&#34;&gt;Bluek404&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://blog.zerob13.in/&#34;&gt;混沌的云&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;献丑集&#34; href=&#34;#献丑集&#34;&gt;&lt;/a&gt;献丑集&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;2014年没有链接的表示还不足以挂出来或者&lt;code&gt;还在准备中&lt;/code&gt;，如果有愿意一起玩的初学朋友赶快来哦~&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2011&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;KJO：基于&lt;code&gt;vs2010&lt;/code&gt;的OI题库管理系统。这是高一时&lt;code&gt;第一次在无人指导下完成&lt;/code&gt;的作品。&lt;/li&gt;&#xA;&lt;li&gt;《*r*m*ife》：不忍直视的3D动画&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;2012&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;康杰中学3D模型：&lt;code&gt;3DsMAX&lt;/code&gt;建模学习&lt;/li&gt;&#xA;&lt;li&gt;坦克大战游戏：&lt;code&gt;HTML5&lt;/code&gt;初体验&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;2013&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/micln/ArmGo&#34;&gt;ArmGo游戏&lt;/a&gt;：通过设计程序指令来控制机械臂。基于&lt;code&gt;HTML5&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;uoj：基于&lt;code&gt;beego&lt;/code&gt;的在线程序评测系统，已残废，并入下面的uscoj，最终都会并入acmclub&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs203.net&#34;&gt;uscoj&lt;/a&gt;：基于HUSTOJ二次开发的在线评测系统。纯属为了交差&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;2014&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[博客前段]()：前段练习&lt;/li&gt;&#xA;&lt;li&gt;acmclub：acm/icpc训练平台&lt;/li&gt;&#xA;&lt;li&gt;ztalk：精简结构却不失强大的论坛系统，主要是为了练习&lt;code&gt;beego&lt;/code&gt;，为 xxx 打基础&lt;/li&gt;&#xA;&lt;li&gt;iPage：&lt;code&gt;iGoogle&lt;/code&gt;一样的个人门户，总得想跟办法把分散四处的信息整理到一起&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>你的第一篇博客</title>
      <link>http://dashayu.tk/2013/new-born.html</link>
      <pubDate>2013-02-08 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;感谢你使用Gor编写博客&lt;/h3&gt;&#xA;&#xA;&lt;h3&gt;本文位于 posts/first-blog.md , 你可以任意删掉,修改这个文件&lt;/h3&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
  </channel>
</rss>